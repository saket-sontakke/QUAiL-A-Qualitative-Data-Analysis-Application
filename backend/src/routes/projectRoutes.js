import express from 'express';
import multer from 'multer';
import mammoth from 'mammoth';
import fs from 'fs';
import path from 'path';
import ExcelJS from 'exceljs';
import axios from 'axios';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import Project from '../models/Project.js';
import { requireAuth } from '../controllers/projectController.js';
import { Document, Packer, Paragraph, TextRun, AlignmentType } from 'docx';
import PDFDocument from 'pdfkit';

dotenv.config();
const router = express.Router();

const MAX_TEXT_SIZE_MB = 25;
const MAX_AUDIO_SIZE_MB = 25;
const MAX_TEXT_SIZE_BYTES = MAX_TEXT_SIZE_MB * 1024 * 1024;
const MAX_AUDIO_SIZE_BYTES = MAX_AUDIO_SIZE_MB * 1024 * 1024;

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const isAudio = /audio\/(mp3|wav|ogg|m4a|aac)/.test(file.mimetype);
    const baseDir = process.env.NODE_ENV === 'test' ? 'test_uploads' : 'uploads';
    const subDir = isAudio ? `${baseDir}/audio` : `${baseDir}/text`;
    if (!fs.existsSync(subDir)) {
      fs.mkdirSync(subDir, { recursive: true });
    }
    cb(null, subDir);
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  },
});

const textUpload = multer({
  storage: fileStorage,
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    if (['.txt', '.docx', '.rtf'].includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error('Unsupported text file type'), false);
    }
  },
  limits: {
    fileSize: MAX_TEXT_SIZE_BYTES,
  }
});

const audioUpload = multer({
  storage: fileStorage,
  fileFilter: (req, file, cb) => {
    const allowedTypes = /audio\/(mp3|wav|ogg|m4a||aac)/;
    if (allowedTypes.test(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Unsupported audio file type'), false);
    }
  },
  limits: {
    fileSize: MAX_AUDIO_SIZE_BYTES,
  }
});

/**
 * Middleware to handle errors generated by Multer, such as file size limits.
 * @param {Error} err - The error object.
 * @param {object} req - The Express request object.
 * @param {object} res - The Express response object.
 * @param {function} next - The next middleware function.
 * @returns {void}
 */
const handleMulterError = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(413).json({ error: `File is too large. Please ensure it is under the size limit.` });
    }
  }
  next(err);
};

/**
 * Creates a new project for the authenticated user.
 * @param {string} req.body.name - The name of the new project.
 * @param {object} [req.body.data] - Optional initial data for the project.
 * @returns {object} 201 - The newly created project object.
 * @returns {object} 409 - An error object if a project with the same name already exists.
 * @returns {object} 500 - An error object if the project creation fails.
 */
router.post('/create', requireAuth, async (req, res) => {
  const { name, data } = req.body;
  try {
    const existingProject = await Project.findOne({
      owner: req.userId,
      name: { $regex: new RegExp(`^${name}$`, 'i') }
    });
    if (existingProject) {
      return res.status(409).json({ error: 'A project with this name already exists.' });
    }
    const newProject = new Project({ name, data, owner: req.userId });
    await newProject.save();
    res.status(201).json(newProject);
  } catch (err) {
    if (err.code === 11000) {
      return res.status(409).json({ error: 'A project with this name already exists.' });
    }
    res.status(500).json({ error: 'Project creation failed', details: err.message });
  }
});

/**
 * Stages a text file for editing without saving it to the project.
 * It processes the file's content and returns it to the client.
 * @param {string} req.params.projectId - The ID of the project to which the file is being staged.
 * @param {object} req.file - The uploaded file object provided by multer.
 * @param {string} [req.body.splittingOption='sentence'] - The processing option for the text content.
 * @param {string} [req.body.overrideName] - An optional name to use if the user confirms a duplicate import.
 * @returns {object} 200 - An object containing the staged file's name and processed content.
 * @returns {object} 400 - An error object if no file is uploaded.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 409 - An error object if a file with the same name already exists, includes a suggested new name.
 * @returns {object} 500 - An error object if the file staging process fails.
 */
router.post('/:projectId/files/stage', requireAuth, textUpload.single('file'), handleMulterError, async (req, res) => {
  const file = req.file;
  const { splittingOption = 'sentence', overrideName } = req.body;

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });

    if (!project) {
      fs.unlinkSync(file.path);
      return res.status(404).json({ error: 'Project not found' });
    }

    const finalFileName = overrideName || file.originalname;

    if (!overrideName) {
        const fileExists = project.importedFiles.some(
            importedFile => importedFile.name.toLowerCase() === file.originalname.toLowerCase()
        );

        if (fileExists) {
            fs.unlinkSync(file.path);
            let suggestedName;
            let counter = 1;
            const ext = path.extname(file.originalname);
            const baseName = path.basename(file.originalname, ext);
            do {
                suggestedName = `${baseName} (${counter})${ext}`;
                counter++;
            } while (project.importedFiles.some(f => f.name.toLowerCase() === suggestedName.toLowerCase()));
            
            return res.status(409).json({
                error: `A file named "${file.originalname}" already exists.`,
                promptRequired: true,
                suggestedName: suggestedName,
            });
        }
    }
    
    let rawText = '';
    const buffer = fs.readFileSync(file.path);
    if (file.mimetype.includes('text') || path.extname(file.originalname).toLowerCase() === '.rtf') {
      rawText = buffer.toString('utf8');
    } else if (file.mimetype.includes('word')) {
      rawText = (await mammoth.extractRawText({ buffer })).value;
    }
    fs.unlinkSync(file.path);

    let processedText = rawText;
    if (splittingOption === 'sentence') {
      const sentences = rawText.replace(/(\r\n|\n|\r)/gm, " ").replace(/\s+/g, ' ').match(/[^.!?…]+[.!?…"]*(\s|$)/g);
      if (sentences && sentences.length > 0) {
        processedText = sentences.map(s => s.trim()).join('\n\n');
      }
    }

    res.json({
      stagedFile: {
        name: finalFileName,
        content: processedText,
        sourceType: 'text',
      }
    });

  } catch (err) {
    if (file && fs.existsSync(file.path)) fs.unlinkSync(file.path);
    console.error('File staging error:', err);
    res.status(500).json({ error: 'File staging failed', details: err.message });
  }
});

/**
 * Commits a new file to a specific project.
 * This endpoint adds a file with its content and optional metadata
 * to a project's `importedFiles` array.
 * @param {string} req.params.projectId - The ID of the project to add the file to.
 * @param {string} req.body.name - The name of the new file.
 * @param {string} req.body.content - The text content of the new file.
 * @param {string} [req.body.sourceType] - The source type of the file (e.g., 'audio', 'text').
 * @param {string} [req.body.audioUrl] - Optional URL if the source is an audio file.
 * @param {Array<object>} [req.body.words] - Optional word-level data for audio transcriptions.
 * @returns {object} 200 - The updated project object, including the newly added file.
 * @returns {object} 400 - An error object if the file name or content is missing.
 * @returns {object} 404 - An error object if the project is not found for the authenticated user.
 * @returns {object} 500 - An error object if saving the file to the database fails.
 */
router.post('/:projectId/files/commit', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const { name, content, sourceType, audioUrl, words } = req.body;

  if (!name || typeof content !== 'string') {
    return res.status(400).json({ error: 'File name and content are required.' });
  }

  try {
    const fileData = {
      name,
      content,
      sourceType,
      ...(audioUrl && { audioUrl }),
      ...(words && { words }),
    };

    const updatedProject = await Project.findOneAndUpdate(
      { _id: projectId, owner: req.userId },
      { $push: { importedFiles: fileData } },
      { new: true }
    );

    if (!updatedProject) {
      return res.status(404).json({ error: 'Project not found.' });
    }

    res.json({ project: updatedProject });
  } catch (err) {
    console.error('File commit error:', err);
    res.status(500).json({ error: 'Failed to save the file.', details: err.message });
  }
});

/**
 * Updates an existing project for the authenticated user.
 * @param {string} req.params.id - The ID of the project to update.
 * @param {string} [req.body.name] - The new name for the project.
 * @param {object} [req.body.data] - The new data for the project.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 404 - An error object if the project is not found or the user is unauthorized.
 * @returns {object} 409 - An error object if another project with the new name already exists.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:id', requireAuth, async (req, res) => {
  const { name, data } = req.body;
  const projectId = req.params.id;
  try {
    if (name) {
      const existingProject = await Project.findOne({
        owner: req.userId,
        name: { $regex: new RegExp(`^${name}$`, 'i') },
        _id: { $ne: projectId }
      });
      if (existingProject) {
        return res.status(409).json({ error: 'Another project with this name already exists.' });
      }
    }
    const project = await Project.findOneAndUpdate({ _id: projectId, owner: req.userId }, { $set: { name, data } }, { new: true, runValidators: true });
    if (!project) {
      return res.status(404).json({ error: 'Project not found or unauthorized' });
    }
    res.json(project);
  } catch (err) {
    if (err.code === 11000) {
      return res.status(409).json({ error: 'Another project with this name already exists.' });
    }
    res.status(500).json({ error: 'Project update failed', details: err.message });
  }
});

/**
 * Fetches all projects owned by the authenticated user.
 * @returns {Array<object>} 200 - An array of project objects.
 * @returns {object} 500 - An error object if fetching fails.
 */
router.get('/my-projects', requireAuth, async (req, res) => {
  try {
    const projects = await Project.find({ owner: req.userId }).sort({ createdAt: -1 });
    res.json(projects);
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch projects', details: err.message });
  }
});

/**
 * Fetches a single project by its ID for the authenticated user.
 * @param {string} req.params.id - The ID of the project to fetch.
 * @returns {object} 200 - The project object.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the server encounters an error.
 */
router.get('/:id', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOne({ _id: req.params.id, owner: req.userId }).lean();
    if (!project) return res.status(404).json({ error: 'Project not found' });
    res.json(project);
  } catch (err) {
    res.status(500).json({ error: 'Server error', details: err.message });
  }
});

/**
 * Deletes a project by its ID for the authenticated user.
 * @param {string} req.params.id - The ID of the project to delete.
 * @returns {object} 200 - A success message.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:id', requireAuth, async (req, res) => {
  try {
    const result = await Project.findOneAndDelete({ _id: req.params.id, owner: req.userId });
    if (!result) return res.status(404).json({ error: 'Not found' });
    res.json({ message: 'Deleted' });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Adds a new code definition to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.body.name - The name of the new code definition.
 * @param {string} [req.body.description] - The description of the code definition.
 * @param {string} [req.body.color] - The color associated with the code definition.
 * @returns {object} 201 - An object containing the updated project.
 * @returns {object} 400 - An error object if the name is missing or already exists.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the creation fails.
 */
router.post('/:projectId/code-definitions', requireAuth, async (req, res) => {
  const { name, description, color } = req.body;
  if (!name) {
    return res.status(400).json({ message: 'Code definition name is required.' });
  }
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    if (project.codeDefinitions.some(cd => cd.name === name)) {
      return res.status(400).json({ error: 'Code definition already exists' });
    }
    project.codeDefinitions.push({ name, description, color, owner: req.userId });
    const updatedProject = await project.save();
    res.status(201).json({ project: updatedProject });
  } catch (err) {
    res.status(500).json({ error: 'Create failed', details: err.message });
  }
});

/**
 * Updates an existing code definition within a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.codeDefId - The ID of the code definition to update.
 * @param {string} req.body.name - The new name for the code definition.
 * @param {string} [req.body.description] - The new description.
 * @param {string} [req.body.color] - The new color.
 * @returns {object} 200 - An object containing the updated project.
 * @returns {object} 404 - An error object if the project or code definition is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/code-definitions/:codeDefId', requireAuth, async (req, res) => {
  const { name, description, color } = req.body;
  const { projectId, codeDefId } = req.params;
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    const codeToUpdate = project.codeDefinitions.id(codeDefId);
    if (!codeToUpdate) {
      return res.status(404).json({ error: 'Code definition not found' });
    }
    codeToUpdate.set({ name, description, color });
    project.codedSegments.forEach(segment => {
      if (segment.codeDefinition && segment.codeDefinition._id.toString() === codeDefId) {
        segment.codeDefinition.name = name;
        segment.codeDefinition.description = description;
        segment.codeDefinition.color = color;
      }
    });
    const updatedProject = await project.save();
    res.json({ project: updatedProject });
  } catch (err) {
    console.error('Update code definition error:', err);
    res.status(500).json({ error: 'Update failed', details: err.message });
  }
});

/**
 * Deletes a code definition and all associated coded segments from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.codeDefId - The ID of the code definition to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/code-definitions/:codeDefId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, {
      $pull: {
        codeDefinitions: { _id: req.params.codeDefId },
        codedSegments: { 'codeDefinition._id': req.params.codeDefId },
      },
    }, { new: true });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    res.json({ message: 'Code definition deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Imports a text file (.txt, .docx, .rtf) into a project.
 * @param {string} req.params.id - The ID of the project.
 * @param {File} req.file - The uploaded file object from Multer.
 * @param {string} [req.body.splittingOption='sentence'] - The method to process the text ('sentence' or other).
 * @param {string} [req.body.overrideName] - An optional name to force-save the file with.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object if no file is uploaded.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 409 - An error object if a file with the same name exists, prompting for a rename.
 * @returns {object} 500 - An error object if the import fails.
 */
router.post('/import/:id', requireAuth, textUpload.single('file'), handleMulterError, async (req, res) => {
  const file = req.file;
  const { splittingOption = 'sentence', overrideName } = req.body;
  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  try {
    const project = await Project.findOne({ _id: req.params.id, owner: req.userId });
    if (!project) {
      fs.unlinkSync(file.path);
      return res.status(404).json({ error: 'Project not found' });
    }
    let finalFileName = overrideName || file.originalname;
    if (!overrideName) {
      const fileExists = project.importedFiles.some(
        importedFile => importedFile.name.toLowerCase() === file.originalname.toLowerCase()
      );
      if (fileExists) {
        fs.unlinkSync(file.path);
        let suggestedName;
        let counter = 1;
        const ext = path.extname(file.originalname);
        const baseName = path.basename(file.originalname, ext);
        do {
          suggestedName = `${baseName} (${counter})${ext}`;
          counter++;
        } while (project.importedFiles.some(f => f.name.toLowerCase() === suggestedName.toLowerCase()));
        return res.status(409).json({
          error: `A file named "${file.originalname}" already exists. Renaming is suggested.`,
          promptRequired: true,
          suggestedName: suggestedName,
        });
      }
    }
    let rawText = '';
    const buffer = fs.readFileSync(file.path);
    if (file.mimetype.includes('text') || path.extname(file.originalname).toLowerCase() === '.rtf') {
      rawText = buffer.toString('utf8');
    } else if (file.mimetype.includes('word')) {
      rawText = (await mammoth.extractRawText({ buffer })).value;
    }
    fs.unlinkSync(file.path);
    let processedText = rawText;
    if (splittingOption === 'sentence') {
      const sentences = rawText.replace(/(\r\n|\n|\r)/gm, " ").replace(/\s+/g, ' ').match(/[^.!?…]+[.!?…"]*(\s|$)/g);
      if (sentences && sentences.length > 0) {
        processedText = sentences.map(s => s.trim()).join('\n\n');
      }
    }
    const updatedProject = await Project.findOneAndUpdate({ _id: req.params.id, owner: req.userId }, { $push: { importedFiles: { name: finalFileName, content: processedText, sourceType: 'text' } } }, { new: true });
    res.json({ project: updatedProject });
  } catch (err) {
    if (file && fs.existsSync(file.path)) fs.unlinkSync(file.path);
    console.error('File import error:', err);
    res.status(500).json({ error: 'File import failed', details: err.message });
  }
});

/**
 * Renames a specific file within a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.fileId - The ID of the file to rename.
 * @param {string} req.body.name - The new name for the file.
 * @returns {object} 200 - The updated project object.
 */
router.put('/:projectId/files/:fileId/rename', requireAuth, async (req, res) => {
  const { name } = req.body;
  const { projectId, fileId } = req.params;

  if (!name || typeof name !== 'string' || name.trim().length === 0) {
    return res.status(400).json({ error: 'A valid new file name is required.' });
  }

  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found.' });
    }

    const fileToUpdate = project.importedFiles.id(fileId);
    if (!fileToUpdate) {
      return res.status(404).json({ error: 'File not found in this project.' });
    }

    const getExtension = (filename) => {
        const lastDot = filename.lastIndexOf('.');
        if (lastDot === -1) return '';
        return filename.substring(lastDot);
    };

    const originalExtension = getExtension(fileToUpdate.name);
    const newExtension = getExtension(name.trim());

    if (originalExtension.toLowerCase() !== newExtension.toLowerCase()) {
        return res.status(400).json({ error: 'Changing the file extension is not allowed.' });
    }

    const fileExists = project.importedFiles.some(
      file => file.name.toLowerCase() === name.toLowerCase() && file._id.toString() !== fileId
    );
    if (fileExists) {
      return res.status(409).json({ error: `A file named "${name}" already exists.` });
    }

    fileToUpdate.name = name.trim();
    await project.save();

    res.json({ project });
  } catch (err) {
    console.error('Error renaming file:', err);
    res.status(500).json({ error: 'Server error while renaming the file.' });
  }
});

/**
 * Deletes a file and all its associated data (coded segments, highlights, memos) from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.fileId - The ID of the file to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project or file is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/files/:fileId', requireAuth, async (req, res) => {
  try {
    const { projectId, fileId } = req.params;
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found or you do not have permission' });
    }
    const fileToDelete = project.importedFiles.id(fileId);
    if (!fileToDelete) {
      return res.status(404).json({ error: 'File not found in project' });
    }
    if (fileToDelete.sourceType === 'audio' && fileToDelete.audioUrl) {
      try {
        const relativePath = fileToDelete.audioUrl.startsWith('/') ? fileToDelete.audioUrl.substring(1) : fileToDelete.audioUrl;
        const fullPath = path.resolve(relativePath);
        if (fs.existsSync(fullPath)) {
          fs.unlinkSync(fullPath);
        } else {
          console.warn(`Audio file not found on disk: ${fullPath}`);
        }
      } catch (fileError) {
        console.error('Error deleting physical audio file:', fileError);
      }
    }
    const updatedProject = await Project.findOneAndUpdate({ _id: projectId, owner: req.userId }, {
      $pull: {
        importedFiles: { _id: fileId },
        codedSegments: { fileId },
        inlineHighlights: { fileId },
        memos: { fileId },
      },
    }, { new: true });
    if (!updatedProject) {
      return res.status(404).json({ error: 'Project not found or you do not have permission' });
    }
    res.json({ message: 'File and related data deleted successfully', project: updatedProject });
  } catch (err) {
    console.error('Delete file error:', err);
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Formats milliseconds into an HH:MM:SS timestamp string.
 * @param {number} ms - The duration in milliseconds.
 * @returns {string} The formatted timestamp string.
 */
const formatTimestamp = (ms) => {
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
  const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
  const seconds = (totalSeconds % 60).toString().padStart(2, '0');
  return `${hours}:${minutes}:${seconds}`;
};

/**
 * Imports an audio file, sends it to AssemblyAI for transcription, and saves the transcript to a project.
 * @param {string} req.params.id - The ID of the project.
 * @param {File} req.file - The uploaded audio file from Multer.
 * @param {string} [req.body.splittingOption='turn'] - The method for formatting the transcript.
 * @returns {object} 200 - The updated project object with the new transcript file.
 * @returns {object} 400 - An error object if no file is uploaded.
 * @returns {object} 500 - An error object if transcription or saving fails.
 */
router.post('/import-audio/:id', requireAuth, audioUpload.single('audio'), handleMulterError, async (req, res) => {
  const file = req.file;
  const { splittingOption = 'turn', overrideName } = req.body;

  if (!file) {
    return res.status(400).json({ error: 'No audio file uploaded.' });
  }

  const ASSEMBLYAI_API_KEY = process.env.ASSEMBLYAI_API_KEY;
  if (!ASSEMBLYAI_API_KEY) {
    fs.unlinkSync(file.path);
    return res.status(500).json({ error: 'AssemblyAI API key not configured on the server.' });
  }

  try {
    const project = await Project.findOne({ _id: req.params.id, owner: req.userId });
    if (!project) {
        fs.unlinkSync(file.path);
        return res.status(404).json({ error: 'Project not found' });
    }

    const originalTranscriptName = file.originalname.replace(/\.[^/.]+$/, " (Transcript).txt");
    let finalTranscriptName = overrideName || originalTranscriptName;

    if (!overrideName) {
        const fileExists = project.importedFiles.some(
            importedFile => importedFile.name.toLowerCase() === finalTranscriptName.toLowerCase()
        );

        if (fileExists) {
            fs.unlinkSync(file.path);
            let suggestedName;
            let counter = 1;
            const ext = path.extname(originalTranscriptName);
            const baseName = path.basename(originalTranscriptName, ext);

            do {
                suggestedName = `${baseName} (${counter})${ext}`;
                counter++;
            } while (project.importedFiles.some(f => f.name.toLowerCase() === suggestedName.toLowerCase()));

            return res.status(409).json({
                error: `A transcript named "${originalTranscriptName}" already exists. Renaming is suggested.`,
                promptRequired: true,
                suggestedName: suggestedName,
            });
        }
    }

    const filePath = file.path;
    const audioUrl = `/${filePath.replace(/\\/g, '/')}`;

    const fileStream = fs.createReadStream(filePath);
    const uploadResponse = await axios({
      method: 'post',
      url: 'https://api.assemblyai.com/v2/upload',
      data: fileStream,
      headers: { 'authorization': ASSEMBLYAI_API_KEY, 'Content-Type': 'application/octet-stream' },
      maxContentLength: Infinity,
      maxBodyLength: Infinity
    });
    
    const uploadUrl = uploadResponse.data.upload_url;
    if (!uploadUrl) throw new Error('No upload URL returned from AssemblyAI');
    
    const transcriptParams = { audio_url: uploadUrl, speaker_labels: true, disfluencies: true, punctuate: true, format_text: true, };
    const transcriptResponse = await axios({
      method: 'post',
      url: 'https://api.assemblyai.com/v2/transcript',
      data: transcriptParams,
      headers: { 'authorization': ASSEMBLYAI_API_KEY, 'Content-Type': 'application/json' }
    });
    
    const transcriptId = transcriptResponse.data.id;
    if (!transcriptId) throw new Error('No transcript ID returned from AssemblyAI');
    
    let transcriptData;
    let pollAttempts = 0;
    const maxPollAttempts = 100;
    
    while (pollAttempts < maxPollAttempts) {
      const pollResponse = await axios({
        method: 'get',
        url: `https://api.assemblyai.com/v2/transcript/${transcriptId}`,
        headers: { 'authorization': ASSEMBLYAI_API_KEY }
      });
      transcriptData = pollResponse.data;
      if (transcriptData.status === 'completed') break;
      if (transcriptData.status === 'error') throw new Error(`Transcription failed: ${transcriptData.error || 'Unknown error'}`);
      await new Promise(resolve => setTimeout(resolve, 3000));
      pollAttempts++;
    }
    
    if (pollAttempts >= maxPollAttempts) throw new Error('Transcription polling timeout - took too long to complete');
    
    let formattedTranscript = '';
    const processedWords = [];
    let currentIndex = 0;
    
    if (transcriptData.words && transcriptData.words.length > 0) {
      if (splittingOption === 'sentence') {
        let fullText = '';
        transcriptData.words.forEach((word, index) => {
          const wordText = word.text + (index < transcriptData.words.length - 1 ? ' ' : '');
          processedWords.push({ text: word.text, startTime: word.start / 1000.0, endTime: word.end / 1000.0, startIndex: fullText.length, endIndex: fullText.length + word.text.length, speaker: word.speaker || 'Unknown', });
          fullText += wordText;
        });
        const sentences = fullText.match(/[^.!?]+[.!?]+/g) || [fullText];
        sentences.forEach((sentence, sentenceIndex) => {
          const trimmedSentence = sentence.trim();
          if (!trimmedSentence) return;
          const sentenceStart = fullText.indexOf(trimmedSentence, sentenceIndex > 0 ? fullText.indexOf(sentences[sentenceIndex - 1]) + sentences[sentenceIndex - 1].length : 0);
          const firstWordInSentence = processedWords.find(word => word.startIndex >= sentenceStart && word.startIndex < sentenceStart + trimmedSentence.length);
          const speaker = firstWordInSentence?.speaker || 'Unknown';
          const timestamp = firstWordInSentence ? formatTimestamp(firstWordInSentence.startTime * 1000) : '00:00:00';
          formattedTranscript += `[${timestamp}] Speaker ${speaker}: ${trimmedSentence}\n\n`;
        });
        currentIndex = formattedTranscript.length;
      } else {
        if (transcriptData.utterances && transcriptData.utterances.length > 0) {
          transcriptData.utterances.forEach((utterance, utteranceIndex) => {
            const timestamp = formatTimestamp(utterance.start);
            const speaker = utterance.speaker || 'A';
            const header = `[${timestamp}] Speaker ${speaker}: `;
            formattedTranscript += header;
            currentIndex += header.length;
            const utteranceWords = transcriptData.words.filter(word => word.start >= utterance.start && word.end <= utterance.end);
            utteranceWords.forEach((word, wordIndex) => {
              const wordText = word.text + (wordIndex < utteranceWords.length - 1 ? ' ' : '');
              processedWords.push({ text: word.text, startTime: word.start / 1000.0, endTime: word.end / 1000.0, startIndex: currentIndex, endIndex: currentIndex + word.text.length, speaker: word.speaker || speaker, });
              formattedTranscript += wordText;
              currentIndex += wordText.length;
            });
            if (utteranceIndex < transcriptData.utterances.length - 1) {
              formattedTranscript += '\n\n';
              currentIndex += 2;
            }
          });
        } else {
          transcriptData.words.forEach((word, index) => {
            const wordText = word.text + (index < transcriptData.words.length - 1 ? ' ' : '');
            processedWords.push({ text: word.text, startTime: word.start / 1000.0, endTime: word.end / 1000.0, startIndex: currentIndex, endIndex: currentIndex + word.text.length, speaker: word.speaker || 'Unknown', });
            formattedTranscript += wordText;
            currentIndex += wordText.length;
          });
        }
      }
    } else {
      formattedTranscript = transcriptData.text || 'No transcript available';
    }

    const updatedProject = await Project.findOneAndUpdate(
        { _id: req.params.id, owner: req.userId }, 
        { $push: { importedFiles: { name: finalTranscriptName, content: formattedTranscript, sourceType: 'audio', audioUrl: audioUrl, words: processedWords } } }, 
        { new: true }
    ).populate('importedFiles');
    
    res.json({ project: updatedProject });

  } catch (error) {
    console.error('Audio import error:', error);
    if (file && fs.existsSync(file.path)) {
      fs.unlinkSync(file.path);
    }
    if (error.response) {
      console.error('AssemblyAI API Error Response:', { status: error.response.status, statusText: error.response.statusText, data: error.response.data, headers: error.response.headers });
    }
    res.status(500).json({ error: 'Audio transcription failed.', details: error.response?.data || error.message });
  }
});

/**
 * Updates the content of a specific file within a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.fileId - The ID of the file to update.
 * @param {string} req.body.content - The new content for the file.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object if the content is missing or not a string.
 * @returns {object} 404 - An error object if the project or file is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/files/:fileId', requireAuth, async (req, res) => {
  const { content } = req.body;
  const { projectId, fileId } = req.params;
  if (typeof content !== 'string') {
    return res.status(400).json({ error: 'Content is required and must be a string.' });
  }
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found or you do not have permission.' });
    }
    const fileToUpdate = project.importedFiles.id(fileId);
    if (!fileToUpdate) {
      return res.status(404).json({ error: 'File not found in this project.' });
    }
    fileToUpdate.content = content;
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error('Error updating file content:', err);
    res.status(500).send('Server Error');
  }
});

/**
 * Adds a new coded segment to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.body.fileId - The ID of the file containing the segment.
 * @param {string} req.body.fileName - The name of the file.
 * @param {string} req.body.text - The text content of the segment.
 * @param {string} req.body.codeDefinitionId - The ID of the code definition to apply.
 * @param {number} req.body.startIndex - The starting character index of the segment.
 * @param {number} req.body.endIndex - The ending character index of the segment.
 * @returns {object} 200 - The updated project object and the newly created segment.
 * @returns {object} 400 - An error object if the code definition is not found.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if adding the segment fails.
 */
router.post('/:projectId/code', requireAuth, async (req, res) => {
  const { fileId, fileName, text, codeDefinitionId, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    const codeDef = project?.codeDefinitions.id(codeDefinitionId);
    if (!codeDef) return res.status(400).json({ error: 'Code definition not found' });
    project.codedSegments.push({
      fileId,
      fileName,
      text,
      startIndex,
      endIndex,
      codeDefinition: { _id: codeDef._id, name: codeDef.name, description: codeDef.description, color: codeDef.color, },
    });
    const updatedProject = await project.save();
    const newSegment = updatedProject.codedSegments.at(-1);
    res.json({ project: updatedProject, newSegment });
  } catch (err) {
    res.status(500).json({ error: 'Add segment failed', details: err.message });
  }
});

/**
 * Deletes a coded segment from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.codeId - The ID of the coded segment to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/code/:codeId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { codedSegments: { _id: req.params.codeId } } }, { new: true });
    res.json({ message: 'Segment deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Updates a coded segment, typically to reassign it to a new code definition.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.segmentId - The ID of the coded segment to update.
 * @param {string} req.body.codeId - The ID of the new code definition to assign.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object if the new code definition is not found.
 * @returns {object} 404 - An error object if the project or segment is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/code/:segmentId', requireAuth, async (req, res) => {
  const { projectId, segmentId } = req.params;
  const { codeId } = req.body;
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const segmentToUpdate = project.codedSegments.id(segmentId);
    if (!segmentToUpdate) return res.status(404).json({ error: 'Coded segment not found' });
    const newCodeDef = project.codeDefinitions.id(codeId);
    if (!newCodeDef) return res.status(400).json({ error: 'The new code definition was not found' });
    segmentToUpdate.codeDefinition = { _id: newCodeDef._id, name: newCodeDef.name, description: newCodeDef.description, color: newCodeDef.color, };
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error("Error updating coded segment:", err);
    res.status(500).json({ error: 'Update failed', details: err.message });
  }
});

/**
 * Merges multiple code definitions into a single new one.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {Array<string>} req.body.sourceCodeIds - An array of code definition IDs to merge.
 * @param {string} req.body.newCodeName - The name for the new merged code.
 * @param {string} req.body.newCodeColor - The color for the new merged code.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object for invalid request data.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the merge fails.
 */
router.post('/:projectId/codes/merge', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const { sourceCodeIds, newCodeName, newCodeColor } = req.body;
  if (!sourceCodeIds || !Array.isArray(sourceCodeIds) || sourceCodeIds.length < 2 || !newCodeName || !newCodeName.trim()) {
    return res.status(400).json({ error: 'Invalid request data. Requires an array of at least two source code IDs and a non-empty new name.' });
  }
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const newCodeDefinition = {
      _id: new mongoose.Types.ObjectId(),
      name: newCodeName,
      color: newCodeColor,
      description: `Merged from codes.`,
      owner: req.userId
    };
    project.codeDefinitions.push(newCodeDefinition);
    project.codedSegments.forEach(segment => {
      if (sourceCodeIds.includes(segment.codeDefinition._id.toString())) {
        segment.codeDefinition = {
          _id: newCodeDefinition._id,
          name: newCodeDefinition.name,
          color: newCodeDefinition.color,
          description: newCodeDefinition.description,
        };
      }
    });
    project.codeDefinitions = project.codeDefinitions.filter(
      def => !sourceCodeIds.includes(def._id.toString())
    );
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error('Merge codes error:', err);
    res.status(500).json({ error: 'Server error during merge', details: err.message });
  }
});

/**
 * Splits a single code definition into multiple new ones and reassigns its segments.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.body.sourceCodeId - The ID of the code definition to split.
 * @param {Array<object>} req.body.newCodeDefinitions - An array of new code definition objects.
 * @param {object} req.body.assignments - An object mapping segment IDs to new code names.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object for invalid request data.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the split fails.
 */
router.post('/:projectId/codes/split', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const { sourceCodeId, newCodeDefinitions, assignments } = req.body;
  if (!sourceCodeId || !newCodeDefinitions || !assignments) {
    return res.status(400).json({ error: 'Invalid request data for split.' });
  }
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const newCodeMap = new Map();
    newCodeDefinitions.forEach(def => {
      const newDef = {
        _id: new mongoose.Types.ObjectId(),
        name: def.name,
        color: def.color,
        description: `Split from original code.`,
        owner: req.userId
      };
      project.codeDefinitions.push(newDef);
      newCodeMap.set(def.name, newDef);
    });
    for (const segmentId in assignments) {
      const newCodeIdentifier = assignments[segmentId];
      const segment = project.codedSegments.id(segmentId);
      if (!segment) continue;
      if (newCodeIdentifier === null) {
        project.codedSegments.pull({ _id: segmentId });
      } else if (newCodeMap.has(newCodeIdentifier)) {
        const newCode = newCodeMap.get(newCodeIdentifier);
        segment.codeDefinition = { _id: newCode._id, name: newCode.name, color: newCode.color, description: newCode.description, };
      }
    }
    project.codeDefinitions = project.codeDefinitions.filter(def => def._id.toString() !== sourceCodeId);
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error('Split codes error:', err);
    res.status(500).json({ error: 'Server error during split', details: err.message });
  }
});

/**
 * Adds a new inline highlight to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {object} req.body - The highlight data.
 * @returns {object} 200 - The updated project object and the new highlight.
 * @returns {object} 500 - An error object if adding the highlight fails.
 */
router.post('/:projectId/highlight', requireAuth, async (req, res) => {
  const { fileId, fileName, text, color, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $push: { inlineHighlights: { fileId, fileName, text, color, startIndex, endIndex } } }, { new: true });
    const newHighlight = project.inlineHighlights.at(-1);
    res.json({ project, newHighlight });
  } catch (err) {
    res.status(500).json({ error: 'Add highlight failed', details: err.message });
  }
});

/**
 * Deletes an inline highlight from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.highlightId - The ID of the highlight to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/highlight/:highlightId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { inlineHighlights: { _id: req.params.highlightId } } }, { new: true });
    res.json({ message: 'Highlight deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Deletes multiple inline highlights from a project in bulk.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {Array<string>} req.body.ids - An array of highlight IDs to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 400 - An error object for an invalid request.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.post('/:projectId/highlight/delete-bulk', requireAuth, async (req, res) => {
  const { ids } = req.body;
  if (!ids || !Array.isArray(ids)) {
    return res.status(400).json({ error: 'Invalid request: "ids" array is required.' });
  }
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { inlineHighlights: { _id: { $in: ids } } } }, { new: true });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    res.json({ message: `${ids.length} highlights deleted`, project });
  } catch (err) {
    res.status(500).json({ error: 'Bulk delete failed', details: err.message });
  }
});

/**
 * Updates an existing memo in a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.memoId - The ID of the memo to update.
 * @param {object} req.body - The updated memo data.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project or memo is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/memos/:memoId', requireAuth, async (req, res) => {
  const { title, content, text, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const memo = project.memos.id(req.params.memoId);
    if (!memo) return res.status(404).json({ error: 'Memo not found' });
    memo.set({ title, content, text, startIndex, endIndex, updatedAt: new Date() });
    const updatedProject = await project.save();
    res.json({ message: 'Memo updated', project: updatedProject });
  } catch (err) {
    console.error('Update memo error:', err);
    res.status(500).json({ error: 'Update memo failed', details: err.message });
  }
});

/**
 * Adds a new memo to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {object} req.body - The memo data.
 * @returns {object} 201 - The new memo object and the updated project object.
 * @returns {object} 401 - An error object if the user is not found.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if adding the memo fails.
 */
router.post('/:projectId/memos', requireAuth, async (req, res) => {
  const { fileId, fileName, text, title, content, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const User = mongoose.model('User');
    const user = await User.findById(req.userId);
    if (!user) return res.status(401).json({ error: 'User not found or unauthorized' });
    project.memos.push({
      fileId,
      fileName,
      text,
      title,
      content,
      startIndex,
      endIndex,
      author: user.name,
      authorId: req.userId,
      createdAt: new Date(),
    });
    await project.save();
    res.status(201).json({ newMemo: project.memos.at(-1), project });
  } catch (err) {
    console.error('Add memo error:', err);
    res.status(500).json({ error: 'Add memo failed', details: err.message });
  }
});

/**
 * Deletes a memo from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.memoId - The ID of the memo to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/memos/:memoId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { memos: { _id: req.params.memoId } } }, { new: true });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    res.json({ message: 'Memo deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete memo failed', details: err.message });
  }
});

/**
 * Converts a HEX color string to an ARGB string for ExcelJS.
 * @param {string} hex - The hex color code.
 * @param {number} [alpha=1.0] - The alpha transparency value.
 * @returns {string} The ARGB color string.
 */
const hexToArgb = (hex, alpha = 1.0) => {
  if (!hex || !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {
    hex = '#CCCCCC';
  }
  let cleanHex = hex.substring(1);
  if (cleanHex.length === 3) {
    cleanHex = cleanHex.split('').map(char => char + char).join('');
  }
  const alphaHex = Math.round(alpha * 255).toString(16).padStart(2, '0').toUpperCase();
  return `${alphaHex}${cleanHex}`;
};

/**
 * Creates a subtle color scheme for Excel cell styling.
 * @param {string} baseHex - The base hex color.
 * @returns {object} An object with fill and border styles.
 */
const createSubtleColorScheme = (baseHex) => {
  return {
    nameCell: { type: 'pattern', pattern: 'solid', fgColor: { argb: hexToArgb(baseHex, 0.15) } },
    contentRows: { type: 'pattern', pattern: 'solid', fgColor: { argb: hexToArgb(baseHex, 0.05) } },
    leftBorder: {
      left: { style: 'thick', color: { argb: hexToArgb(baseHex, 0.8) } },
      right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
    },
    standardBorder: {
      left: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
    }
  };
};

/**
 * Applies a subtle color scheme to a range of cells in an Excel worksheet.
 * @param {object} worksheet - The ExcelJS worksheet object.
 * @param {number} codeStartRow - The starting row for the colored block.
 * @param {number} codeEndRow - The ending row for the colored block.
 * @param {string} baseHexColor - The base hex color for styling.
 * @param {object} columns - An object defining column letters.
 * @returns {void}
 */
const applySubtleColoring = (worksheet, codeStartRow, codeEndRow, baseHexColor, columns) => {
  const colors = createSubtleColorScheme(baseHexColor);
  const nameColumn = columns.nameColumn;
  worksheet.getCell(`${nameColumn}${codeStartRow}`).fill = colors.nameCell;
  worksheet.getCell(`${nameColumn}${codeStartRow}`).font = { bold: true };
  worksheet.getCell(`${nameColumn}${codeStartRow}`).border = colors.leftBorder;
  columns.otherColumns.forEach(col => {
    worksheet.getCell(`${col}${codeStartRow}`).fill = colors.contentRows;
    worksheet.getCell(`${col}${codeStartRow}`).border = colors.standardBorder;
  });
  for (let i = codeStartRow; i <= codeEndRow; i++) {
    columns.contentColumns.forEach(col => {
      worksheet.getCell(`${col}${i}`).fill = colors.contentRows;
      worksheet.getCell(`${col}${i}`).border = colors.standardBorder;
      worksheet.getCell(`${col}${i}`).alignment = { vertical: 'top', horizontal: 'left', wrapText: true };
    });
  }
  worksheet.getCell(`${nameColumn}${codeStartRow}`).alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
  columns.otherColumns.forEach(col => {
    worksheet.getCell(`${col}${codeStartRow}`).alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
  });
};

/**
 * Exports all coded segments from a project to an Excel file.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} [req.query.format='byDocument'] - The format of the export ('byDocument', 'overall', or 'matrix').
 * @returns {File} 200 - The generated Excel file.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the export fails.
 */
// router.get('/:projectId/export-coded-segments', requireAuth, async (req, res) => {
//   const { projectId } = req.params;
//   const userId = req.userId;
//   const { format = 'byDocument' } = req.query;

//   try {
//     const project = await Project.findOne({ _id: projectId, owner: userId }).lean();
//     if (!project) {
//       return res.status(404).json({ error: 'Project not found or unauthorized' });
//     }
//     const workbook = new ExcelJS.Workbook();

//     if (format === 'matrix') {
//         const worksheet = workbook.addWorksheet('Code Matrix Report');
  
//         const sortedCodeDefs = [...project.codeDefinitions].sort((a, b) => a.name.localeCompare(b.name));
//         const allCodeNames = sortedCodeDefs.map(cd => cd.name);
//         const codeNameToColorMap = new Map(sortedCodeDefs.map(cd => [cd.name, cd.color || '#CCCCCC']));
//         const codeKeys = allCodeNames.map(name => name.replace(/[^a-zA-Z0-9]/g, ''));
  
//         const headers = ['Document', 'Timestamp', 'Speaker', 'Segment Text', ...allCodeNames, 'Total'];
//         worksheet.columns = headers.map((h, i) => ({
//           header: h,
//           key: i < 4 ? h.toLowerCase().replace(/\s+/g, '') : (i < headers.length - 1 ? codeKeys[i - 4] : 'total'),
//         }));
  
//         const headerRow = worksheet.getRow(1);
//         headerRow.font = { bold: true };
//         headerRow.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
  
//         allCodeNames.forEach((name, index) => {
//           const cell = headerRow.getCell(5 + index);
//           const color = codeNameToColorMap.get(name);
//           cell.fill = {
//             type: 'pattern',
//             pattern: 'solid',
//             fgColor: { argb: hexToArgb(color, 0.25) }
//           };
//         });
  
//         const audioFiles = project.importedFiles.filter(file => file.sourceType === 'audio');
//         let currentRowIndex = 2;
  
//         for (const file of audioFiles) {
//           const fileStartRow = currentRowIndex;
//           const fileContent = file.content || '';
//           const segmentsForThisFile = project.codedSegments.filter(cs => cs.fileId.toString() === file._id.toString());
//           const lines = fileContent.split('\n');
//           let currentPosition = 0;
  
//           for (const lineText of lines) {
//             const lineLength = lineText.length;
//             const lineStart = currentPosition;
//             const lineEnd = currentPosition + lineLength;
//             currentPosition += lineLength + 1;
  
//             if (lineText.trim() === '') continue;
  
//             let rowData = {};
//             let rowTotal = 0;
  
//             const transcriptLineRegex = /^(\[.+?\])\s*(Speaker\s+[A-Z0-9]+):\s*(.*)/;
//             const match = lineText.match(transcriptLineRegex);
//             if (match) {
//               rowData.timestamp = (match[1] || '').replace(/[\[\]]/g, '');
//               rowData.speaker = match[2] || '';
//               rowData.segmenttext = match[3] || '';
//             } else {
//               rowData.timestamp = '';
//               rowData.speaker = '';
//               rowData.segmenttext = lineText;
//             }
  
//             codeKeys.forEach(key => rowData[key] = '');
  
//             segmentsForThisFile.forEach(segment => {
//               if (Math.max(lineStart, segment.startIndex) < Math.min(lineEnd, segment.endIndex)) {
//                 const codeName = segment.codeDefinition.name;
//                 const codeIndex = allCodeNames.indexOf(codeName);
//                 if (codeIndex > -1) {
//                   const key = codeKeys[codeIndex];
//                   if (rowData[key] !== 1) {
//                     rowData[key] = 1;
//                     rowTotal++;
//                   }
//                 }
//               }
//             });
  
//             rowData.total = rowTotal > 0 ? rowTotal : '';
//             rowData.document = file.name;
  
//             worksheet.addRow(rowData);
//             currentRowIndex++;
//           }
  
//           const fileEndRow = currentRowIndex - 1;
//           if (fileEndRow >= fileStartRow) {
//             worksheet.mergeCells(`A${fileStartRow}:A${fileEndRow}`);
//           }
//         }
  
//         const summaryRowIndex = currentRowIndex;
//         const summaryRow = worksheet.addRow({});
//         summaryRow.getCell('segmenttext').value = 'Total';
//         summaryRow.font = { bold: true };
  
//         for (let i = 0; i < allCodeNames.length; i++) {
//           const colLetter = String.fromCharCode('E'.charCodeAt(0) + i);
//           summaryRow.getCell(5 + i).value = { formula: `SUM(${colLetter}2:${colLetter}${summaryRowIndex - 1})` };
//         }
//         const totalColLetter = String.fromCharCode('E'.charCodeAt(0) + allCodeNames.length);
//         summaryRow.getCell(headers.length).value = { formula: `SUM(${totalColLetter}2:${totalColLetter}${summaryRowIndex - 1})` };
  
//         worksheet.columns.forEach((column, index) => {
//           if (index === 0) column.width = 30;
//           else if (index === 1) column.width = 12;
//           else if (index === 2) column.width = 20;
//           else if (index === 3) column.width = 60;
//           else if (index < headers.length - 1) column.width = column.header.length > 15 ? 20 : 15;
//           else column.width = 10;
//         });
  
//         for (let i = 2; i <= summaryRowIndex; i++) {
//           const row = worksheet.getRow(i);
//           row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
//             cell.alignment = { wrapText: true };
//             if (colNumber === 4) {
//               cell.alignment.vertical = 'top';
//               cell.alignment.horizontal = 'left';
//             } else {
//               cell.alignment.vertical = 'middle';
//               cell.alignment.horizontal = 'center';
//             }
  
//             if (colNumber >= 5 && colNumber < headers.length) {
//               const headerName = headers[colNumber - 1];
//               const color = codeNameToColorMap.get(headerName);
//               if (color) {
//                 cell.fill = {
//                   type: 'pattern',
//                   pattern: 'solid',
//                   fgColor: { argb: hexToArgb(color, 0.08) }
//                 };
//               }
//             }
//           });
//         }
  
//         for (let i = 1; i <= summaryRowIndex; i++) {
//           const row = worksheet.getRow(i);
//           row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
//             if (colNumber > headers.length) return;
  
//             const isExcludedSummaryCell = (i === summaryRowIndex && colNumber < 4);
  
//             if (!isExcludedSummaryCell) {
//               cell.border = {
//                 top: { style: 'thin', color: { argb: 'FF000000' } },
//                 left: { style: 'thin', color: { argb: 'FF000000' } },
//                 bottom: { style: 'thin', color: { argb: 'FF000000' } },
//                 right: { style: 'thin', color: { argb: 'FF000000' } }
//               };
//             }
//           });
//         }
  
//         const date = new Date().toISOString().slice(0, 10);
//         res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
//         res.setHeader('Content-Disposition', `attachment; filename="${project.name}_Code_Matrix_${date}.xlsx"`);
//         await workbook.xlsx.write(res);
//         return res.end();
//       }

//     const worksheet = workbook.addWorksheet('Coded Segments');
//     let totalFrequency = 0;
    
//     const styleHeader = (ws) => {
//       const headerRow = ws.getRow(1);
//       headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
//       headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF444444' } };
//       headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
//       headerRow.eachCell({ includeEmpty: true }, (cell) => {
//         cell.border = {
//           top: { style: 'thin', color: { argb: 'FF6A6A6A' } },
//           left: { style: 'thin', color: { argb: 'FF6A6A6A' } },
//           bottom: { style: 'thin', color: { argb: 'FF6A6A6A' } },
//           right: { style: 'thin', color: { argb: 'FF6A6A6A' } }
//         };
//       });
//     };

//     if (format === 'overall') {
//       worksheet.columns = [
//         { header: 'Code Definition', key: 'codeName', width: 30 },
//         { header: 'Code Description', key: 'codeDescription', width: 40 },
//         { header: 'File Name', key: 'fileName', width: 30 },
//         { header: 'Coded Segment Text', key: 'text', width: 60 },
//         { header: 'Frequency', key: 'frequency', width: 15 },
//       ];
//       styleHeader(worksheet);

//       const groupedByCode = {};
//       project.codedSegments.forEach(segment => {
//         const defId = segment.codeDefinition?._id?.toString() || 'undefined';
//         if (!groupedByCode[defId]) {
//           groupedByCode[defId] = { definition: segment.codeDefinition, segments: [] };
//         }
//         groupedByCode[defId].segments.push(segment);
//       });

//       let currentRow = 2;
//       for (const { definition, segments } of Object.values(groupedByCode)) {
//         const codeStartRow = currentRow;
//         const baseHexColor = definition?.color || '#CCCCCC';

//         const segmentsByFile = segments.reduce((acc, segment) => {
//             const fileName = segment.fileName || 'Unknown File';
//             if (!acc[fileName]) acc[fileName] = [];
//             acc[fileName].push(segment);
//             return acc;
//         }, {});

//         for (const [fileName, fileSegments] of Object.entries(segmentsByFile)) {
//             for (const segment of fileSegments) {
//                 worksheet.addRow({ text: `"${segment.text || ''}"` });
//                 currentRow++;
//             }
//         }

//         const codeEndRow = currentRow - 1;
//         worksheet.mergeCells(`A${codeStartRow}:A${codeEndRow}`);
//         worksheet.mergeCells(`B${codeStartRow}:B${codeEndRow}`);
//         worksheet.mergeCells(`E${codeStartRow}:E${codeEndRow}`);
//         worksheet.getCell(`A${codeStartRow}`).value = definition?.name || 'Unknown Code';
//         worksheet.getCell(`B${codeStartRow}`).value = definition?.description || 'No description';
//         worksheet.getCell(`E${codeStartRow}`).value = segments.length;

//         applySubtleColoring(worksheet, codeStartRow, codeEndRow, baseHexColor, {
//           nameColumn: 'A',
//           otherColumns: ['B', 'E'],
//           contentColumns: ['C', 'D']
//         });

//         let fileRowTracker = codeStartRow;
//         for (const [fileName, fileSegments] of Object.entries(segmentsByFile)) {
//             const fileStartRow = fileRowTracker;
//             const fileEndRow = fileRowTracker + fileSegments.length - 1;
//             if (fileEndRow >= fileStartRow) {
//                 worksheet.mergeCells(`C${fileStartRow}:C${fileEndRow}`);
//                 const fileCell = worksheet.getCell(`C${fileStartRow}`);
//                 fileCell.value = fileName;
//                 fileCell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
//             }
//             fileRowTracker = fileEndRow + 1;
//         }
//       }
//       totalFrequency = project.codedSegments.length;
//     } else {
//       worksheet.columns = [
//         { header: 'File Name', key: 'fileName', width: 30 },
//         { header: 'Code Definition', key: 'codeName', width: 25 },
//         { header: 'Code Description', key: 'codeDescription', width: 40 },
//         { header: 'Coded Segment Text', key: 'text', width: 60 },
//         { header: 'Frequency', key: 'frequency', width: 15 },
//       ];
//       styleHeader(worksheet);
      
//       const groupedByFile = {};
//       project.codedSegments.forEach(segment => {
//         const fileName = segment.fileName || 'Unknown File';
//         if (!groupedByFile[fileName]) groupedByFile[fileName] = [];
//         groupedByFile[fileName].push(segment);
//       });
//       let currentRow = 2;
      
//       for (const [fileName, segmentsInFile] of Object.entries(groupedByFile)) {
//         const fileStartRow = currentRow;
//         const groupedByCode = {};
//         segmentsInFile.forEach(segment => {
//           const defId = segment.codeDefinition?._id?.toString() || 'undefined';
//           if (!groupedByCode[defId]) {
//             groupedByCode[defId] = { definition: segment.codeDefinition, segments: [] };
//           }
//           groupedByCode[defId].segments.push(segment);
//         });
        
//         for (const { definition, segments } of Object.values(groupedByCode)) {
//           const codeStartRow = currentRow;
//           const baseHexColor = definition?.color || '#CCCCCC';
          
//           for (const segment of segments) {
//             worksheet.addRow({ text: `"${segment.text || ''}"` });
//             currentRow++;
//           }
          
//           const codeEndRow = currentRow - 1;
//           worksheet.mergeCells(`B${codeStartRow}:B${codeEndRow}`);
//           worksheet.mergeCells(`C${codeStartRow}:C${codeEndRow}`);
//           worksheet.mergeCells(`E${codeStartRow}:E${codeEndRow}`);
//           worksheet.getCell(`B${codeStartRow}`).value = definition?.name || 'Unknown Code';
//           worksheet.getCell(`C${codeStartRow}`).value = definition?.description || 'No description';
//           worksheet.getCell(`E${codeStartRow}`).value = segments.length;
          
//           applySubtleColoring(worksheet, codeStartRow, codeEndRow, baseHexColor, {
//             nameColumn: 'B',
//             otherColumns: ['C', 'E'],
//             contentColumns: ['D']
//           });
//         }
        
//         const fileEndRow = currentRow - 1;
//         if (fileEndRow >= fileStartRow) {
//           worksheet.mergeCells(`A${fileStartRow}:A${fileEndRow}`);
//           const firstCell = worksheet.getCell(`A${fileStartRow}`);
//           firstCell.value = fileName;
//           firstCell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
//           firstCell.font = { bold: true };

//           for (let i = fileStartRow; i <= fileEndRow; i++) {
//             const cell = worksheet.getCell(`A${i}`);
//             cell.fill = {
//               type: 'pattern',
//               pattern: 'solid',
//               fgColor: { argb: 'FFF5F5F5' }
//             };
//             cell.border = {
//               left: { style: 'thick', color: { argb: 'FF666666' } },
//               right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
//               top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
//               bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
//             };
//           }
//         }
//       }
//       totalFrequency = project.codedSegments.length;
//     }
//     const totalRow = worksheet.addRow({});
//     const totalLabelCell = worksheet.getCell(totalRow.number, worksheet.columns.length - 1);
//     const totalValueCell = worksheet.getCell(totalRow.number, worksheet.columns.length);
//     totalLabelCell.value = 'Total Frequency';
//     totalValueCell.value = totalFrequency;
//     totalLabelCell.font = { bold: true };
//     totalValueCell.font = { bold: true };
//     totalLabelCell.alignment = { horizontal: 'right' };
//     totalValueCell.alignment = { horizontal: 'center' };
//     totalLabelCell.border = {
//       top: { style: 'thick', color: { argb: 'FF666666' } }
//     };
//     totalValueCell.border = {
//       top: { style: 'thick', color: { argb: 'FF666666' } }
//     };
//     res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
//     res.setHeader('Content-Disposition', `attachment; filename="${project.name}_coded_segments_${format}.xlsx"`);
//     await workbook.xlsx.write(res);
//     res.end();
//   } catch (err) {
//     console.error('[EXPORT ERROR]', err);
//     res.status(500).json({ error: 'Failed to export coded segments', details: err.message });
//   }
// });
/**
 * Exports all coded segments from a project to an Excel file.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} [req.query.format='byDocument'] - The format of the export ('byDocument', 'overall', or 'matrix').
 * @returns {File} 200 - The generated Excel file.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the export fails.
 */
router.get('/:projectId/export-coded-segments', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const userId = req.userId;
  const { format = 'byDocument' } = req.query;

  try {
    const project = await Project.findOne({ _id: projectId, owner: userId }).lean();
    if (!project) {
      return res.status(404).json({ error: 'Project not found or unauthorized' });
    }
    const workbook = new ExcelJS.Workbook();

    if (format === 'matrix') {
        const worksheet = workbook.addWorksheet('Code Matrix Report');
  
        const sortedCodeDefs = [...project.codeDefinitions].sort((a, b) => a.name.localeCompare(b.name));
        const allCodeNames = sortedCodeDefs.map(cd => cd.name);
        const codeNameToColorMap = new Map(sortedCodeDefs.map(cd => [cd.name, cd.color || '#CCCCCC']));
        const codeKeys = allCodeNames.map(name => name.replace(/[^a-zA-Z0-9]/g, ''));
  
        const headers = ['Document', 'Timestamp', 'Speaker', 'Segment Text', ...allCodeNames, 'Total'];
        worksheet.columns = headers.map((h, i) => ({
          header: h,
          key: i < 4 ? h.toLowerCase().replace(/\s+/g, '') : (i < headers.length - 1 ? codeKeys[i - 4] : 'total'),
        }));
  
        const headerRow = worksheet.getRow(1);
        headerRow.font = { bold: true };
        headerRow.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
  
        allCodeNames.forEach((name, index) => {
          const cell = headerRow.getCell(5 + index);
          const color = codeNameToColorMap.get(name);
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: hexToArgb(color, 0.25) }
          };
        });
        
        // --- START OF MODIFIED LOGIC ---
        
        const allFiles = project.importedFiles; // MODIFICATION: Process all imported files
        let currentRowIndex = 2;
  
        for (const file of allFiles) { // MODIFICATION: Loop over all files
          const fileStartRow = currentRowIndex;
          const fileContent = file.content || '';
          const segmentsForThisFile = project.codedSegments.filter(cs => cs.fileId.toString() === file._id.toString());
          const lines = fileContent.split('\n');
          let currentPosition = 0;
  
          for (const lineText of lines) {
            const lineLength = lineText.length;
            const lineStart = currentPosition;
            const lineEnd = currentPosition + lineLength;
            currentPosition += lineLength + 1;
  
            if (lineText.trim() === '') continue;
  
            let rowData = {};
            let rowTotal = 0;
  
            // MODIFICATION: Final, robust regex to handle optional timestamps and flexible identifiers
            const transcriptLineRegex = /^(?:(\[.+?\])\s*)?([^:]+):\s*(.*)/;
            const match = lineText.match(transcriptLineRegex);

            if (match) {
                const timestampValue = (match[1] || '').replace(/[\[\]]/g, '');
                rowData.timestamp = timestampValue || '-'; // MODIFICATION: Use hyphen for missing timestamps
                rowData.speaker = (match[2] || '').trim();
                rowData.segmenttext = (match[3] || '').trim();
            } else {
                rowData.timestamp = '-'; // MODIFICATION: Use hyphen for plain text lines
                rowData.speaker = '';
                rowData.segmenttext = lineText;
            }
  
            codeKeys.forEach(key => rowData[key] = '');
  
            segmentsForThisFile.forEach(segment => {
              if (Math.max(lineStart, segment.startIndex) < Math.min(lineEnd, segment.endIndex)) {
                const codeName = segment.codeDefinition.name;
                const codeIndex = allCodeNames.indexOf(codeName);
                if (codeIndex > -1) {
                  const key = codeKeys[codeIndex];
                  if (rowData[key] !== 1) {
                    rowData[key] = 1;
                    rowTotal++;
                  }
                }
              }
            });
  
            rowData.total = rowTotal > 0 ? rowTotal : '';
            rowData.document = file.name;
  
            worksheet.addRow(rowData);
            currentRowIndex++;
          }
  
          const fileEndRow = currentRowIndex - 1;
          if (fileEndRow >= fileStartRow) {
            worksheet.mergeCells(`A${fileStartRow}:A${fileEndRow}`);
          }
        }
        
        // --- END OF MODIFIED LOGIC ---
  
        const summaryRowIndex = currentRowIndex;
        const summaryRow = worksheet.addRow({});
        summaryRow.getCell('segmenttext').value = 'Total';
        summaryRow.font = { bold: true };
  
        for (let i = 0; i < allCodeNames.length; i++) {
          const colLetter = String.fromCharCode('E'.charCodeAt(0) + i);
          summaryRow.getCell(5 + i).value = { formula: `SUM(${colLetter}2:${colLetter}${summaryRowIndex - 1})` };
        }
        const totalColLetter = String.fromCharCode('E'.charCodeAt(0) + allCodeNames.length);
        summaryRow.getCell(headers.length).value = { formula: `SUM(${totalColLetter}2:${totalColLetter}${summaryRowIndex - 1})` };
  
        worksheet.columns.forEach((column, index) => {
          if (index === 0) column.width = 30;
          else if (index === 1) column.width = 12;
          else if (index === 2) column.width = 20;
          else if (index === 3) column.width = 60;
          else if (index < headers.length - 1) column.width = column.header.length > 15 ? 20 : 15;
          else column.width = 10;
        });
  
        for (let i = 2; i <= summaryRowIndex; i++) {
          const row = worksheet.getRow(i);
          row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
            cell.alignment = { wrapText: true };
            if (colNumber === 4) {
              cell.alignment.vertical = 'top';
              cell.alignment.horizontal = 'left';
            } else {
              cell.alignment.vertical = 'middle';
              cell.alignment.horizontal = 'center';
            }
  
            if (colNumber >= 5 && colNumber < headers.length) {
              const headerName = headers[colNumber - 1];
              const color = codeNameToColorMap.get(headerName);
              if (color) {
                cell.fill = {
                  type: 'pattern',
                  pattern: 'solid',
                  fgColor: { argb: hexToArgb(color, 0.08) }
                };
              }
            }
          });
        }
  
        for (let i = 1; i <= summaryRowIndex; i++) {
          const row = worksheet.getRow(i);
          row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
            if (colNumber > headers.length) return;
  
            const isExcludedSummaryCell = (i === summaryRowIndex && colNumber < 4);
  
            if (!isExcludedSummaryCell) {
              cell.border = {
                top: { style: 'thin', color: { argb: 'FF000000' } },
                left: { style: 'thin', color: { argb: 'FF000000' } },
                bottom: { style: 'thin', color: { argb: 'FF000000' } },
                right: { style: 'thin', color: { argb: 'FF000000' } }
              };
            }
          });
        }
  
        const date = new Date().toISOString().slice(0, 10);
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename="${project.name}_Code_Matrix_${date}.xlsx"`);
        await workbook.xlsx.write(res);
        return res.end();
      }

    // This is the fallback logic for 'overall' and 'byDocument' formats. It remains unchanged.
    const worksheet = workbook.addWorksheet('Coded Segments');
    let totalFrequency = 0;
    
    const styleHeader = (ws) => {
      const headerRow = ws.getRow(1);
      headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
      headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF444444' } };
      headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
      headerRow.eachCell({ includeEmpty: true }, (cell) => {
        cell.border = {
          top: { style: 'thin', color: { argb: 'FF6A6A6A' } },
          left: { style: 'thin', color: { argb: 'FF6A6A6A' } },
          bottom: { style: 'thin', color: { argb: 'FF6A6A6A' } },
          right: { style: 'thin', color: { argb: 'FF6A6A6A' } }
        };
      });
    };

    if (format === 'overall') {
      worksheet.columns = [
        { header: 'Code Definition', key: 'codeName', width: 30 },
        { header: 'Code Description', key: 'codeDescription', width: 40 },
        { header: 'File Name', key: 'fileName', width: 30 },
        { header: 'Coded Segment Text', key: 'text', width: 60 },
        { header: 'Frequency', key: 'frequency', width: 15 },
      ];
      styleHeader(worksheet);

      const groupedByCode = {};
      project.codedSegments.forEach(segment => {
        const defId = segment.codeDefinition?._id?.toString() || 'undefined';
        if (!groupedByCode[defId]) {
          groupedByCode[defId] = { definition: segment.codeDefinition, segments: [] };
        }
        groupedByCode[defId].segments.push(segment);
      });

      let currentRow = 2;
      for (const { definition, segments } of Object.values(groupedByCode)) {
        const codeStartRow = currentRow;
        const baseHexColor = definition?.color || '#CCCCCC';

        const segmentsByFile = segments.reduce((acc, segment) => {
            const fileName = segment.fileName || 'Unknown File';
            if (!acc[fileName]) acc[fileName] = [];
            acc[fileName].push(segment);
            return acc;
        }, {});

        for (const [fileName, fileSegments] of Object.entries(segmentsByFile)) {
            for (const segment of fileSegments) {
                worksheet.addRow({ text: `"${segment.text || ''}"` });
                currentRow++;
            }
        }

        const codeEndRow = currentRow - 1;
        worksheet.mergeCells(`A${codeStartRow}:A${codeEndRow}`);
        worksheet.mergeCells(`B${codeStartRow}:B${codeEndRow}`);
        worksheet.mergeCells(`E${codeStartRow}:E${codeEndRow}`);
        worksheet.getCell(`A${codeStartRow}`).value = definition?.name || 'Unknown Code';
        worksheet.getCell(`B${codeStartRow}`).value = definition?.description || 'No description';
        worksheet.getCell(`E${codeStartRow}`).value = segments.length;

        applySubtleColoring(worksheet, codeStartRow, codeEndRow, baseHexColor, {
          nameColumn: 'A',
          otherColumns: ['B', 'E'],
          contentColumns: ['C', 'D']
        });

        let fileRowTracker = codeStartRow;
        for (const [fileName, fileSegments] of Object.entries(segmentsByFile)) {
            const fileStartRow = fileRowTracker;
            const fileEndRow = fileRowTracker + fileSegments.length - 1;
            if (fileEndRow >= fileStartRow) {
                worksheet.mergeCells(`C${fileStartRow}:C${fileEndRow}`);
                const fileCell = worksheet.getCell(`C${fileStartRow}`);
                fileCell.value = fileName;
                fileCell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
            }
            fileRowTracker = fileEndRow + 1;
        }
      }
      totalFrequency = project.codedSegments.length;
    } else {
      worksheet.columns = [
        { header: 'File Name', key: 'fileName', width: 30 },
        { header: 'Code Definition', key: 'codeName', width: 25 },
        { header: 'Code Description', key: 'codeDescription', width: 40 },
        { header: 'Coded Segment Text', key: 'text', width: 60 },
        { header: 'Frequency', key: 'frequency', width: 15 },
      ];
      styleHeader(worksheet);
      
      const groupedByFile = {};
      project.codedSegments.forEach(segment => {
        const fileName = segment.fileName || 'Unknown File';
        if (!groupedByFile[fileName]) groupedByFile[fileName] = [];
        groupedByFile[fileName].push(segment);
      });
      let currentRow = 2;
      
      for (const [fileName, segmentsInFile] of Object.entries(groupedByFile)) {
        const fileStartRow = currentRow;
        const groupedByCode = {};
        segmentsInFile.forEach(segment => {
          const defId = segment.codeDefinition?._id?.toString() || 'undefined';
          if (!groupedByCode[defId]) {
            groupedByCode[defId] = { definition: segment.codeDefinition, segments: [] };
          }
          groupedByCode[defId].segments.push(segment);
        });
        
        for (const { definition, segments } of Object.values(groupedByCode)) {
          const codeStartRow = currentRow;
          const baseHexColor = definition?.color || '#CCCCCC';
          
          for (const segment of segments) {
            worksheet.addRow({ text: `"${segment.text || ''}"` });
            currentRow++;
          }
          
          const codeEndRow = currentRow - 1;
          worksheet.mergeCells(`B${codeStartRow}:B${codeEndRow}`);
          worksheet.mergeCells(`C${codeStartRow}:C${codeEndRow}`);
          worksheet.mergeCells(`E${codeStartRow}:E${codeEndRow}`);
          worksheet.getCell(`B${codeStartRow}`).value = definition?.name || 'Unknown Code';
          worksheet.getCell(`C${codeStartRow}`).value = definition?.description || 'No description';
          worksheet.getCell(`E${codeStartRow}`).value = segments.length;
          
          applySubtleColoring(worksheet, codeStartRow, codeEndRow, baseHexColor, {
            nameColumn: 'B',
            otherColumns: ['C', 'E'],
            contentColumns: ['D']
          });
        }
        
        const fileEndRow = currentRow - 1;
        if (fileEndRow >= fileStartRow) {
          worksheet.mergeCells(`A${fileStartRow}:A${fileEndRow}`);
          const firstCell = worksheet.getCell(`A${fileStartRow}`);
          firstCell.value = fileName;
          firstCell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
          firstCell.font = { bold: true };

          for (let i = fileStartRow; i <= fileEndRow; i++) {
            const cell = worksheet.getCell(`A${i}`);
            cell.fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FFF5F5F5' }
            };
            cell.border = {
              left: { style: 'thick', color: { argb: 'FF666666' } },
              right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
              top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
              bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
            };
          }
        }
      }
      totalFrequency = project.codedSegments.length;
    }
    const totalRow = worksheet.addRow({});
    const totalLabelCell = worksheet.getCell(totalRow.number, worksheet.columns.length - 1);
    const totalValueCell = worksheet.getCell(totalRow.number, worksheet.columns.length);
    totalLabelCell.value = 'Total Frequency';
    totalValueCell.value = totalFrequency;
    totalLabelCell.font = { bold: true };
    totalValueCell.font = { bold: true };
    totalLabelCell.alignment = { horizontal: 'right' };
    totalValueCell.alignment = { horizontal: 'center' };
    totalLabelCell.border = {
      top: { style: 'thick', color: { argb: 'FF666666' } }
    };
    totalValueCell.border = {
      top: { style: 'thick', color: { argb: 'FF666666' } }
    };
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename="${project.name}_coded_segments_${format}.xlsx"`);
    await workbook.xlsx.write(res);
    res.end();
  } catch (err) {
    console.error('[EXPORT ERROR]', err);
    res.status(500).json({ error: 'Failed to export coded segments', details: err.message });
  }
});

/**
 * Exports all overlapping code segments, with UI-aligned color styling for codes,
 * to a single Excel worksheet that includes a full statistical summary.
 * @param {string} req.params.projectId - The ID of the project.
 * @returns {File} 200 - The generated Excel file.
 * @returns {object} 404 - An error object if the project is not found or no overlaps exist.
 * @returns {object} 500 - An error object if the export fails.
 */
router.get('/:projectId/export-overlaps', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const userId = req.userId;

  try {
    const project = await Project.findOne({ _id: projectId, owner: userId }).lean();
    if (!project) {
      return res.status(404).json({ error: 'Project not found or unauthorized' });
    }

    const overlapsByFile = {};
    const segmentsByFile = project.codedSegments.reduce((acc, segment) => {
      const fileId = segment.fileId.toString();
      if (!acc[fileId]) acc[fileId] = [];
      acc[fileId].push(segment);
      return acc;
    }, {});

    for (const fileId in segmentsByFile) {
        const segments = segmentsByFile[fileId];
        if (segments.length < 2) continue;
        const file = project.importedFiles.find(f => f._id.toString() === fileId);
        if (!file?.content) continue;

        const boundaryPoints = new Set();
        segments.forEach(s => {
            boundaryPoints.add(s.startIndex);
            boundaryPoints.add(s.endIndex);
        });
        const sortedPoints = Array.from(boundaryPoints).sort((a, b) => a - b);

        const fileOverlaps = [];
        for (let i = 0; i < sortedPoints.length - 1; i++) {
            const intervalStart = sortedPoints[i];
            const intervalEnd = sortedPoints[i + 1];
            if (intervalStart === intervalEnd) continue;

            const coveringSegments = segments.filter(s => s.startIndex <= intervalStart && s.endIndex >= intervalEnd);
            if (coveringSegments.length > 1) {
                const allCodes = coveringSegments.map(s => s.codeDefinition).filter(Boolean);
                const uniqueCodes = Array.from(new Map(allCodes.map(code => [code._id.toString(), code])).values());
                fileOverlaps.push({
                    start: intervalStart,
                    end: intervalEnd,
                    text: file.content.substring(intervalStart, intervalEnd),
                    codes: uniqueCodes,
                });
            }
        }

        if (fileOverlaps.length > 0) {
            const mergedOverlaps = [];
            let currentOverlap = { ...fileOverlaps[0] };
            for (let i = 1; i < fileOverlaps.length; i++) {
                const nextOverlap = fileOverlaps[i];
                const currentCodeIds = currentOverlap.codes.map(c => c._id.toString()).sort();
                const nextCodeIds = nextOverlap.codes.map(c => c._id.toString()).sort();
                if (nextOverlap.start === currentOverlap.end && JSON.stringify(currentCodeIds) === JSON.stringify(nextCodeIds)) {
                    currentOverlap.end = nextOverlap.end;
                    currentOverlap.text += nextOverlap.text;
                } else {
                    mergedOverlaps.push(currentOverlap);
                    currentOverlap = { ...nextOverlap };
                }
            }
            mergedOverlaps.push(currentOverlap);
            overlapsByFile[fileId] = { document: file, overlaps: mergedOverlaps };
        }
    }
    
    const finalOverlaps = Object.values(overlapsByFile);
    if (finalOverlaps.length === 0) {
      return res.status(404).json({ error: 'No overlapping codes found in the project to export.' });
    }

    const totalOverlapRegions = finalOverlaps.reduce((total, fileGroup) => total + fileGroup.overlaps.length, 0);
    const documentsWithOverlaps = finalOverlaps.length;
    const totalDocuments = project.importedFiles.length;
    const totalOverlapTextLength = finalOverlaps.reduce((total, fileGroup) => 
        total + fileGroup.overlaps.reduce((fileTotal, overlap) => fileTotal + overlap.text.length, 0), 0
    );
    const averageOverlapLength = totalOverlapRegions > 0 ? Math.round(totalOverlapTextLength / totalOverlapRegions) : 0;
    
    const allOverlapCodes = new Set();
    const codePairFrequency = {};
    finalOverlaps.forEach(fileGroup => {
      fileGroup.overlaps.forEach(overlap => {
        overlap.codes.forEach(code => allOverlapCodes.add(code.name));
        if (overlap.codes.length >= 2) {
          const sortedCodeNames = overlap.codes.map(c => c.name).sort();
          for (let i = 0; i < sortedCodeNames.length; i++) {
            for (let j = i + 1; j < sortedCodeNames.length; j++) {
              const pair = `${sortedCodeNames[i]} & ${sortedCodeNames[j]}`;
              codePairFrequency[pair] = (codePairFrequency[pair] || 0) + 1;
            }
          }
        }
      });
    });
    const uniqueCodesList = Array.from(allOverlapCodes).sort();
    const mostFrequentPair = Object.entries(codePairFrequency).sort(([,a], [,b]) => b - a)[0];

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Overlapping Codes Report');
    
    worksheet.getCell('A1').value = 'Total Overlap Regions:';
    worksheet.getCell('B1').value = totalOverlapRegions;
    worksheet.getCell('C1').value = 'Documents with Overlaps:';
    worksheet.getCell('D1').value = `${documentsWithOverlaps} / ${totalDocuments} Docs`;
    worksheet.getCell('E1').value = 'Most Frequent Pair:';
    worksheet.getCell('F1').value = mostFrequentPair ? `${mostFrequentPair[0]} (${mostFrequentPair[1]} times)` : 'N/A';
    
    worksheet.getCell('A2').value = 'Unique Codes Involved:';
    worksheet.getCell('B2').value = uniqueCodesList.join(', ') || 'N/A';
    worksheet.getCell('C2').value = 'Total Overlap Text:';
    worksheet.getCell('D2').value = `${totalOverlapTextLength} characters`;
    worksheet.getCell('E2').value = 'Average Overlap Length:';
    worksheet.getCell('F2').value = `${averageOverlapLength} characters`;
    
    [1, 2].forEach(rowNum => {
      worksheet.getRow(rowNum).eachCell({ includeEmpty: true }, (cell, colNum) => {
        if (colNum % 2 === 1) { 
          cell.font = { bold: true };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF0F2F5' } };
        } else { 
          cell.font = { color: { argb: 'FF1D3C87' } };
        }
        cell.border = { top: {style:'thin'}, left: {style:'thin'}, bottom: {style:'thin'}, right: {style:'thin'} };
        cell.alignment = { vertical: 'middle', horizontal: 'left', wrapText: true };
      });
    });
    
    worksheet.addRow({});
    const headerRow = worksheet.getRow(4);
    headerRow.values = ['File Name', 'Overlapping Text', 'Applied Codes', 'Code Count'];
    headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF444444' } };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    
    worksheet.getColumn('A').width = 30;
    worksheet.getColumn('B').width = 60;
    worksheet.getColumn('C').width = 40;
    worksheet.getColumn('D').width = 15;
    worksheet.getColumn('E').width = 30;
    worksheet.getColumn('F').width = 40; 

    let currentRowIndex = 5;
    finalOverlaps.forEach(fileGroup => {
      const fileStartRow = currentRowIndex;
      fileGroup.overlaps.forEach(overlap => {
        
        const richTextValue = [];
        overlap.codes.forEach((code, index) => {
          richTextValue.push({
            text: code.name,
            font: {
              color: { argb: hexToArgb(code.color || '#808080') }, 
              bold: true,
            }
          });
          if (index < overlap.codes.length - 1) {
            richTextValue.push({
              text: ', ',
              font: { color: { argb: 'FF000000' } } 
            });
          }
        });
        
        const rowData = [
          null, 
          `"${overlap.text}"`,
          { richText: richTextValue }, 
          overlap.codes.length
        ];
        
        worksheet.addRow(rowData);
        currentRowIndex++;
      });
      
      const fileEndRow = currentRowIndex - 1;
      if (fileEndRow >= fileStartRow) {
        worksheet.mergeCells(`A${fileStartRow}:A${fileEndRow}`);
        const fileNameCell = worksheet.getCell(`A${fileStartRow}`);
        fileNameCell.value = fileGroup.document.name;
        fileNameCell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
        fileNameCell.font = { bold: true };
        fileNameCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF5F5F5' } };
      }
    });

    for (let i = 4; i < currentRowIndex; i++) {
        const row = worksheet.getRow(i);
        row.eachCell({ includeEmpty: true }, (cell) => {
            cell.border = { top: {style:'thin'}, left: {style:'thin'}, bottom: {style:'thin'}, right: {style:'thin'} };
            if (i > 4) {
                 cell.alignment = { ...cell.alignment, vertical: 'top', wrapText: true };
            }
        });
    }

    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename="${project.name}_overlaps_report.xlsx"`);
    await workbook.xlsx.write(res);
    res.end();

  } catch (err) {
    console.error('[OVERLAPS EXPORT ERROR]', err);
    res.status(500).json({ error: 'Failed to export overlapping codes', details: err.message });
  }
});

/**
 * Exports all memos for a single file to an Excel file.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.fileId - The ID of the file to export memos from.
 * @returns {File} 200 - The generated Excel file.
 * @returns {object} 404 - An error object if the project or file is not found.
 * @returns {object} 500 - An error object if the export fails.
 */
router.get('/:projectId/files/:fileId/export-memos', requireAuth, async (req, res) => {
  const { projectId, fileId } = req.params;
  try {
    const project = await Project.findById(projectId);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const file = project.importedFiles.id(fileId);
    if (!file) return res.status(404).json({ error: 'File not found' });

    const memosForFile = project.memos.filter(memo => memo.fileId && memo.fileId.toString() === fileId);
    if (memosForFile.length === 0) {
      return res.status(404).json({ error: 'No memos found for this file.' });
    }

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Memos');
    worksheet.columns = [
      { header: 'File Name', key: 'fileName', width: 25 },
      { header: 'Title', key: 'title', width: 30 },
      { header: 'Content', key: 'content', width: 50 },
      { header: 'Author', key: 'author', width: 20 },
      { header: 'Created At', key: 'createdAt', width: 25 },
    ];
    memosForFile.forEach(memo => {
      worksheet.addRow({
        fileName: memo.fileName,
        title: memo.title || '',
        content: memo.content,
        author: memo.author,
        createdAt: memo.createdAt ?
          memo.createdAt.toLocaleString('en-GB', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
          }) :
          '',
      });
    });

    const sanitizedFileName = file.name.replace(/\.[^/.]+$/, '').replace(/[^\w\s-]/g, '').replace(/\s+/g, '_');
    res.setHeader(
      'Content-Type',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );
    res.setHeader('Content-Disposition', `attachment; filename=${sanitizedFileName}_memos.xlsx`);
    await workbook.xlsx.write(res);
    res.end();
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to export memos.' });
  }
});

/**
 * Exports a specific file from a project in a user-requested format (e.g., DOCX or PDF).
 * The function retrieves the file content and uses appropriate libraries to generate
 * the document in the specified format, streaming it back to the client for download.
 *
 * @param {string} req.params.projectId - The ID of the project containing the file.
 * @param {string} req.params.fileId - The ID of the file to be exported.
 * @param {string} req.query.format - The desired export format. Supported values: 'docx', 'pdf'.
 * @returns {File} 200 - The generated file (DOCX or PDF) for download.
 * @returns {object} 400 - An error object if the requested format is invalid or not supported.
 * @returns {object} 404 - An error object if the project or file is not found.
 * @returns {object} 500 - An error object if the file generation or export process fails.
 */
router.get('/:projectId/files/:fileId/export', requireAuth, async (req, res) => {
  const { projectId, fileId } = req.params;
  const { format } = req.query;

  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found.' });
    }

    const file = project.importedFiles.id(fileId);
    if (!file) {
      return res.status(404).json({ error: 'File not found.' });
    }

    const baseName = path.basename(file.name, path.extname(file.name));

    if (format === 'docx') {
      const paragraphs = file.content.split('\n').map(line => new Paragraph({
        alignment: AlignmentType.JUSTIFIED,
        children: [new TextRun(line)],
      }));
      const doc = new Document({
        sections: [{
          properties: {},
          children: paragraphs,
        }],
      });

      const buffer = await Packer.toBuffer(doc);
      res.setHeader('Content-Disposition', `attachment; filename="${baseName}.docx"`);
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
      res.send(buffer);

    } else if (format === 'pdf') {
      const doc = new PDFDocument();
      let filename = `${baseName}.pdf`;
      filename = encodeURIComponent(filename);
      res.setHeader('Content-disposition', `attachment; filename*=UTF-8''${filename}`);
      res.setHeader('Content-type', 'application/pdf');

      doc.pipe(res);
      doc.fontSize(12).text(file.content, {
        align: 'justify'
      });
      doc.end();

    } else {
      return res.status(400).json({ error: 'Invalid or unsupported format specified.' });
    }
  } catch (err) {
    console.error('File export error:', err);
    res.status(500).json({ error: 'Failed to export file.' });
  }
});

export default router;