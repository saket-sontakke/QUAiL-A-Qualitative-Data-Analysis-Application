import express from 'express';
import multer from 'multer';
import mammoth from 'mammoth';
import fs from 'fs';
import path from 'path';
import ExcelJS from 'exceljs';
import axios from 'axios';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import Project from '../models/Project.js';
import { requireAuth } from '../controllers/projectController.js';

dotenv.config();
const router = express.Router();

const MAX_TEXT_SIZE_MB = 25;
const MAX_AUDIO_SIZE_MB = 25;
const MAX_TEXT_SIZE_BYTES = MAX_TEXT_SIZE_MB * 1024 * 1024;
const MAX_AUDIO_SIZE_BYTES = MAX_AUDIO_SIZE_MB * 1024 * 1024;

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const isAudio = /audio\/(mp3|wav|ogg|m4a|aac)/.test(file.mimetype);
    const baseDir = process.env.NODE_ENV === 'test' ? 'test_uploads' : 'uploads';
    const subDir = isAudio ? `${baseDir}/audio` : `${baseDir}/text`;
    if (!fs.existsSync(subDir)) {
      fs.mkdirSync(subDir, { recursive: true });
    }
    cb(null, subDir);
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  },
});

const textUpload = multer({
  storage: fileStorage,
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    if (['.txt', '.docx', '.rtf'].includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error('Unsupported text file type'), false);
    }
  },
  limits: {
    fileSize: MAX_TEXT_SIZE_BYTES,
  }
});

const audioUpload = multer({
  storage: fileStorage,
  fileFilter: (req, file, cb) => {
    const allowedTypes = /audio\/(mp3|wav|ogg|m4a||aac)/;
    if (allowedTypes.test(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Unsupported audio file type'), false);
    }
  },
  limits: {
    fileSize: MAX_AUDIO_SIZE_BYTES,
  }
});

/**
 * Middleware to handle errors generated by Multer, such as file size limits.
 * @param {Error} err - The error object.
 * @param {object} req - The Express request object.
 * @param {object} res - The Express response object.
 * @param {function} next - The next middleware function.
 * @returns {void}
 */
const handleMulterError = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(413).json({ error: `File is too large. Please ensure it is under the size limit.` });
    }
  }
  next(err);
};

/**
 * Creates a new project for the authenticated user.
 * @param {string} req.body.name - The name of the new project.
 * @param {object} [req.body.data] - Optional initial data for the project.
 * @returns {object} 201 - The newly created project object.
 * @returns {object} 409 - An error object if a project with the same name already exists.
 * @returns {object} 500 - An error object if the project creation fails.
 */
router.post('/create', requireAuth, async (req, res) => {
  const { name, data } = req.body;
  try {
    const existingProject = await Project.findOne({
      owner: req.userId,
      name: { $regex: new RegExp(`^${name}$`, 'i') }
    });
    if (existingProject) {
      return res.status(409).json({ error: 'A project with this name already exists.' });
    }
    const newProject = new Project({ name, data, owner: req.userId });
    await newProject.save();
    res.status(201).json(newProject);
  } catch (err) {
    if (err.code === 11000) {
      return res.status(409).json({ error: 'A project with this name already exists.' });
    }
    res.status(500).json({ error: 'Project creation failed', details: err.message });
  }
});

/**
 * Updates an existing project for the authenticated user.
 * @param {string} req.params.id - The ID of the project to update.
 * @param {string} [req.body.name] - The new name for the project.
 * @param {object} [req.body.data] - The new data for the project.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 404 - An error object if the project is not found or the user is unauthorized.
 * @returns {object} 409 - An error object if another project with the new name already exists.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:id', requireAuth, async (req, res) => {
  const { name, data } = req.body;
  const projectId = req.params.id;
  try {
    if (name) {
      const existingProject = await Project.findOne({
        owner: req.userId,
        name: { $regex: new RegExp(`^${name}$`, 'i') },
        _id: { $ne: projectId }
      });
      if (existingProject) {
        return res.status(409).json({ error: 'Another project with this name already exists.' });
      }
    }
    const project = await Project.findOneAndUpdate({ _id: projectId, owner: req.userId }, { $set: { name, data } }, { new: true, runValidators: true });
    if (!project) {
      return res.status(404).json({ error: 'Project not found or unauthorized' });
    }
    res.json(project);
  } catch (err) {
    if (err.code === 11000) {
      return res.status(409).json({ error: 'Another project with this name already exists.' });
    }
    res.status(500).json({ error: 'Project update failed', details: err.message });
  }
});

/**
 * Fetches all projects owned by the authenticated user.
 * @returns {Array<object>} 200 - An array of project objects.
 * @returns {object} 500 - An error object if fetching fails.
 */
router.get('/my-projects', requireAuth, async (req, res) => {
  try {
    const projects = await Project.find({ owner: req.userId }).sort({ createdAt: -1 });
    res.json(projects);
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch projects', details: err.message });
  }
});

/**
 * Fetches a single project by its ID for the authenticated user.
 * @param {string} req.params.id - The ID of the project to fetch.
 * @returns {object} 200 - The project object.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the server encounters an error.
 */
router.get('/:id', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOne({ _id: req.params.id, owner: req.userId }).lean();
    if (!project) return res.status(404).json({ error: 'Project not found' });
    res.json(project);
  } catch (err) {
    res.status(500).json({ error: 'Server error', details: err.message });
  }
});

/**
 * Deletes a project by its ID for the authenticated user.
 * @param {string} req.params.id - The ID of the project to delete.
 * @returns {object} 200 - A success message.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:id', requireAuth, async (req, res) => {
  try {
    const result = await Project.findOneAndDelete({ _id: req.params.id, owner: req.userId });
    if (!result) return res.status(404).json({ error: 'Not found' });
    res.json({ message: 'Deleted' });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Adds a new code definition to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.body.name - The name of the new code definition.
 * @param {string} [req.body.description] - The description of the code definition.
 * @param {string} [req.body.color] - The color associated with the code definition.
 * @returns {object} 201 - An object containing the updated project.
 * @returns {object} 400 - An error object if the name is missing or already exists.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the creation fails.
 */
router.post('/:projectId/code-definitions', requireAuth, async (req, res) => {
  const { name, description, color } = req.body;
  if (!name) {
    return res.status(400).json({ message: 'Code definition name is required.' });
  }
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    if (project.codeDefinitions.some(cd => cd.name === name)) {
      return res.status(400).json({ error: 'Code definition already exists' });
    }
    project.codeDefinitions.push({ name, description, color, owner: req.userId });
    const updatedProject = await project.save();
    res.status(201).json({ project: updatedProject });
  } catch (err) {
    res.status(500).json({ error: 'Create failed', details: err.message });
  }
});

/**
 * Updates an existing code definition within a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.codeDefId - The ID of the code definition to update.
 * @param {string} req.body.name - The new name for the code definition.
 * @param {string} [req.body.description] - The new description.
 * @param {string} [req.body.color] - The new color.
 * @returns {object} 200 - An object containing the updated project.
 * @returns {object} 404 - An error object if the project or code definition is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/code-definitions/:codeDefId', requireAuth, async (req, res) => {
  const { name, description, color } = req.body;
  const { projectId, codeDefId } = req.params;
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    const codeToUpdate = project.codeDefinitions.id(codeDefId);
    if (!codeToUpdate) {
      return res.status(404).json({ error: 'Code definition not found' });
    }
    codeToUpdate.set({ name, description, color });
    project.codedSegments.forEach(segment => {
      if (segment.codeDefinition && segment.codeDefinition._id.toString() === codeDefId) {
        segment.codeDefinition.name = name;
        segment.codeDefinition.description = description;
        segment.codeDefinition.color = color;
      }
    });
    const updatedProject = await project.save();
    res.json({ project: updatedProject });
  } catch (err) {
    console.error('Update code definition error:', err);
    res.status(500).json({ error: 'Update failed', details: err.message });
  }
});

/**
 * Deletes a code definition and all associated coded segments from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.codeDefId - The ID of the code definition to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/code-definitions/:codeDefId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, {
      $pull: {
        codeDefinitions: { _id: req.params.codeDefId },
        codedSegments: { 'codeDefinition._id': req.params.codeDefId },
      },
    }, { new: true });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    res.json({ message: 'Code definition deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Imports a text file (.txt, .docx, .rtf) into a project.
 * @param {string} req.params.id - The ID of the project.
 * @param {File} req.file - The uploaded file object from Multer.
 * @param {string} [req.body.splittingOption='sentence'] - The method to process the text ('sentence' or other).
 * @param {string} [req.body.overrideName] - An optional name to force-save the file with.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object if no file is uploaded.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 409 - An error object if a file with the same name exists, prompting for a rename.
 * @returns {object} 500 - An error object if the import fails.
 */
router.post('/import/:id', requireAuth, textUpload.single('file'), handleMulterError, async (req, res) => {
  const file = req.file;
  const { splittingOption = 'sentence', overrideName } = req.body;
  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  try {
    const project = await Project.findOne({ _id: req.params.id, owner: req.userId });
    if (!project) {
      fs.unlinkSync(file.path);
      return res.status(404).json({ error: 'Project not found' });
    }
    let finalFileName = overrideName || file.originalname;
    if (!overrideName) {
      const fileExists = project.importedFiles.some(
        importedFile => importedFile.name.toLowerCase() === file.originalname.toLowerCase()
      );
      if (fileExists) {
        fs.unlinkSync(file.path);
        let suggestedName;
        let counter = 1;
        const ext = path.extname(file.originalname);
        const baseName = path.basename(file.originalname, ext);
        do {
          suggestedName = `${baseName} (${counter})${ext}`;
          counter++;
        } while (project.importedFiles.some(f => f.name.toLowerCase() === suggestedName.toLowerCase()));
        return res.status(409).json({
          error: `A file named "${file.originalname}" already exists. Renaming is suggested.`,
          promptRequired: true,
          suggestedName: suggestedName,
        });
      }
    }
    let rawText = '';
    const buffer = fs.readFileSync(file.path);
    if (file.mimetype.includes('text') || path.extname(file.originalname).toLowerCase() === '.rtf') {
      rawText = buffer.toString('utf8');
    } else if (file.mimetype.includes('word')) {
      rawText = (await mammoth.extractRawText({ buffer })).value;
    }
    fs.unlinkSync(file.path);
    let processedText = rawText;
    if (splittingOption === 'sentence') {
      const sentences = rawText.replace(/(\r\n|\n|\r)/gm, " ").replace(/\s+/g, ' ').match(/[^.!?…]+[.!?…"]*(\s|$)/g);
      if (sentences && sentences.length > 0) {
        processedText = sentences.map(s => s.trim()).join('\n\n');
      }
    }
    const updatedProject = await Project.findOneAndUpdate({ _id: req.params.id, owner: req.userId }, { $push: { importedFiles: { name: finalFileName, content: processedText, sourceType: 'text' } } }, { new: true });
    res.json({ project: updatedProject });
  } catch (err) {
    if (file && fs.existsSync(file.path)) fs.unlinkSync(file.path);
    console.error('File import error:', err);
    res.status(500).json({ error: 'File import failed', details: err.message });
  }
});

/**
 * Deletes a file and all its associated data (coded segments, highlights, memos) from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.fileId - The ID of the file to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project or file is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/files/:fileId', requireAuth, async (req, res) => {
  try {
    const { projectId, fileId } = req.params;
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found or you do not have permission' });
    }
    const fileToDelete = project.importedFiles.id(fileId);
    if (!fileToDelete) {
      return res.status(404).json({ error: 'File not found in project' });
    }
    if (fileToDelete.sourceType === 'audio' && fileToDelete.audioUrl) {
      try {
        const relativePath = fileToDelete.audioUrl.startsWith('/') ? fileToDelete.audioUrl.substring(1) : fileToDelete.audioUrl;
        const fullPath = path.resolve(relativePath);
        if (fs.existsSync(fullPath)) {
          fs.unlinkSync(fullPath);
          console.log(`Successfully deleted audio file: ${fullPath}`);
        } else {
          console.warn(`Audio file not found on disk: ${fullPath}`);
        }
      } catch (fileError) {
        console.error('Error deleting physical audio file:', fileError);
      }
    }
    const updatedProject = await Project.findOneAndUpdate({ _id: projectId, owner: req.userId }, {
      $pull: {
        importedFiles: { _id: fileId },
        codedSegments: { fileId },
        inlineHighlights: { fileId },
        memos: { fileId },
      },
    }, { new: true });
    if (!updatedProject) {
      return res.status(404).json({ error: 'Project not found or you do not have permission' });
    }
    res.json({ message: 'File and related data deleted successfully', project: updatedProject });
  } catch (err) {
    console.error('Delete file error:', err);
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Formats milliseconds into an HH:MM:SS timestamp string.
 * @param {number} ms - The duration in milliseconds.
 * @returns {string} The formatted timestamp string.
 */
const formatTimestamp = (ms) => {
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
  const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
  const seconds = (totalSeconds % 60).toString().padStart(2, '0');
  return `${hours}:${minutes}:${seconds}`;
};

/**
 * Imports an audio file, sends it to AssemblyAI for transcription, and saves the transcript to a project.
 * @param {string} req.params.id - The ID of the project.
 * @param {File} req.file - The uploaded audio file from Multer.
 * @param {string} [req.body.splittingOption='turn'] - The method for formatting the transcript.
 * @returns {object} 200 - The updated project object with the new transcript file.
 * @returns {object} 400 - An error object if no file is uploaded.
 * @returns {object} 500 - An error object if transcription or saving fails.
 */
router.post('/import-audio/:id', requireAuth, audioUpload.single('audio'), handleMulterError, async (req, res) => {
  const file = req.file;
  const splittingOption = req.body.splittingOption || 'turn';
  if (!file) {
    return res.status(400).json({ error: 'No audio file uploaded.' });
  }
  const ASSEMBLYAI_API_KEY = process.env.ASSEMBLYAI_API_KEY;
  if (!ASSEMBLYAI_API_KEY) {
    fs.unlinkSync(file.path);
    return res.status(500).json({ error: 'AssemblyAI API key not configured on the server.' });
  }
  const filePath = file.path;
  const audioUrl = `/${filePath.replace(/\\/g, '/')}`;
  try {
    const fileStream = fs.createReadStream(filePath);
    const uploadResponse = await axios({
      method: 'post',
      url: 'https://api.assemblyai.com/v2/upload',
      data: fileStream,
      headers: { 'authorization': ASSEMBLYAI_API_KEY, 'Content-Type': 'application/octet-stream' },
      maxContentLength: Infinity,
      maxBodyLength: Infinity
    });
    const uploadUrl = uploadResponse.data.upload_url;
    if (!uploadUrl) throw new Error('No upload URL returned from AssemblyAI');
    const transcriptParams = { audio_url: uploadUrl, speaker_labels: true, disfluencies: true, punctuate: true, format_text: true, };
    const transcriptResponse = await axios({
      method: 'post',
      url: 'https://api.assemblyai.com/v2/transcript',
      data: transcriptParams,
      headers: { 'authorization': ASSEMBLYAI_API_KEY, 'Content-Type': 'application/json' }
    });
    const transcriptId = transcriptResponse.data.id;
    if (!transcriptId) throw new Error('No transcript ID returned from AssemblyAI');
    let transcriptData;
    let pollAttempts = 0;
    const maxPollAttempts = 100;
    while (pollAttempts < maxPollAttempts) {
      const pollResponse = await axios({
        method: 'get',
        url: `https://api.assemblyai.com/v2/transcript/${transcriptId}`,
        headers: { 'authorization': ASSEMBLYAI_API_KEY }
      });
      transcriptData = pollResponse.data;
      if (transcriptData.status === 'completed') break;
      if (transcriptData.status === 'error') throw new Error(`Transcription failed: ${transcriptData.error || 'Unknown error'}`);
      await new Promise(resolve => setTimeout(resolve, 3000));
      pollAttempts++;
    }
    if (pollAttempts >= maxPollAttempts) throw new Error('Transcription polling timeout - took too long to complete');
    let formattedTranscript = '';
    const processedWords = [];
    let currentIndex = 0;
    if (transcriptData.words && transcriptData.words.length > 0) {
      if (splittingOption === 'sentence') {
        let fullText = '';
        transcriptData.words.forEach((word, index) => {
          const wordText = word.text + (index < transcriptData.words.length - 1 ? ' ' : '');
          processedWords.push({ text: word.text, startTime: word.start / 1000.0, endTime: word.end / 1000.0, startIndex: fullText.length, endIndex: fullText.length + word.text.length, speaker: word.speaker || 'Unknown', });
          fullText += wordText;
        });
        const sentences = fullText.match(/[^.!?]+[.!?]+/g) || [fullText];
        sentences.forEach((sentence, sentenceIndex) => {
          const trimmedSentence = sentence.trim();
          if (!trimmedSentence) return;
          const sentenceStart = fullText.indexOf(trimmedSentence, sentenceIndex > 0 ? fullText.indexOf(sentences[sentenceIndex - 1]) + sentences[sentenceIndex - 1].length : 0);
          const firstWordInSentence = processedWords.find(word => word.startIndex >= sentenceStart && word.startIndex < sentenceStart + trimmedSentence.length);
          const speaker = firstWordInSentence?.speaker || 'Unknown';
          const timestamp = firstWordInSentence ? formatTimestamp(firstWordInSentence.startTime * 1000) : '00:00:00';
          formattedTranscript += `[${timestamp}] Speaker ${speaker}: ${trimmedSentence}\n\n`;
        });
        currentIndex = formattedTranscript.length;
      } else {
        if (transcriptData.utterances && transcriptData.utterances.length > 0) {
          transcriptData.utterances.forEach((utterance, utteranceIndex) => {
            const timestamp = formatTimestamp(utterance.start);
            const speaker = utterance.speaker || 'A';
            const header = `[${timestamp}] Speaker ${speaker}: `;
            formattedTranscript += header;
            currentIndex += header.length;
            const utteranceWords = transcriptData.words.filter(word => word.start >= utterance.start && word.end <= utterance.end);
            utteranceWords.forEach((word, wordIndex) => {
              const wordText = word.text + (wordIndex < utteranceWords.length - 1 ? ' ' : '');
              processedWords.push({ text: word.text, startTime: word.start / 1000.0, endTime: word.end / 1000.0, startIndex: currentIndex, endIndex: currentIndex + word.text.length, speaker: word.speaker || speaker, });
              formattedTranscript += wordText;
              currentIndex += wordText.length;
            });
            if (utteranceIndex < transcriptData.utterances.length - 1) {
              formattedTranscript += '\n\n';
              currentIndex += 2;
            }
          });
        } else {
          transcriptData.words.forEach((word, index) => {
            const wordText = word.text + (index < transcriptData.words.length - 1 ? ' ' : '');
            processedWords.push({ text: word.text, startTime: word.start / 1000.0, endTime: word.end / 1000.0, startIndex: currentIndex, endIndex: currentIndex + word.text.length, speaker: word.speaker || 'Unknown', });
            formattedTranscript += wordText;
            currentIndex += wordText.length;
          });
        }
      }
    } else {
      formattedTranscript = transcriptData.text || 'No transcript available';
    }
    const newFileName = file.originalname.replace(/\.[^/.]+$/, " (Transcript).txt");
    const project = await Project.findOneAndUpdate({ _id: req.params.id, owner: req.userId }, { $push: { importedFiles: { name: newFileName, content: formattedTranscript, sourceType: 'audio', audioUrl: audioUrl, words: processedWords } } }, { new: true }).populate('importedFiles');
    res.json({ project });
  } catch (error) {
    console.error('Audio import error:', error);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
    if (error.response) {
      console.error('AssemblyAI API Error Response:', { status: error.response.status, statusText: error.response.statusText, data: error.response.data, headers: error.response.headers });
    }
    res.status(500).json({ error: 'Audio transcription failed.', details: error.response?.data || error.message });
  }
});

/**
 * Updates the content of a specific file within a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.fileId - The ID of the file to update.
 * @param {string} req.body.content - The new content for the file.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object if the content is missing or not a string.
 * @returns {object} 404 - An error object if the project or file is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/files/:fileId', requireAuth, async (req, res) => {
  const { content } = req.body;
  const { projectId, fileId } = req.params;
  if (typeof content !== 'string') {
    return res.status(400).json({ error: 'Content is required and must be a string.' });
  }
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found or you do not have permission.' });
    }
    const fileToUpdate = project.importedFiles.id(fileId);
    if (!fileToUpdate) {
      return res.status(404).json({ error: 'File not found in this project.' });
    }
    fileToUpdate.content = content;
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error('Error updating file content:', err);
    res.status(500).send('Server Error');
  }
});

/**
 * Adds a new coded segment to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.body.fileId - The ID of the file containing the segment.
 * @param {string} req.body.fileName - The name of the file.
 * @param {string} req.body.text - The text content of the segment.
 * @param {string} req.body.codeDefinitionId - The ID of the code definition to apply.
 * @param {number} req.body.startIndex - The starting character index of the segment.
 * @param {number} req.body.endIndex - The ending character index of the segment.
 * @returns {object} 200 - The updated project object and the newly created segment.
 * @returns {object} 400 - An error object if the code definition is not found.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if adding the segment fails.
 */
router.post('/:projectId/code', requireAuth, async (req, res) => {
  const { fileId, fileName, text, codeDefinitionId, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    const codeDef = project?.codeDefinitions.id(codeDefinitionId);
    if (!codeDef) return res.status(400).json({ error: 'Code definition not found' });
    project.codedSegments.push({
      fileId,
      fileName,
      text,
      startIndex,
      endIndex,
      codeDefinition: { _id: codeDef._id, name: codeDef.name, description: codeDef.description, color: codeDef.color, },
    });
    const updatedProject = await project.save();
    const newSegment = updatedProject.codedSegments.at(-1);
    res.json({ project: updatedProject, newSegment });
  } catch (err) {
    res.status(500).json({ error: 'Add segment failed', details: err.message });
  }
});

/**
 * Deletes a coded segment from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.codeId - The ID of the coded segment to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/code/:codeId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { codedSegments: { _id: req.params.codeId } } }, { new: true });
    res.json({ message: 'Segment deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Updates a coded segment, typically to reassign it to a new code definition.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.segmentId - The ID of the coded segment to update.
 * @param {string} req.body.codeId - The ID of the new code definition to assign.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object if the new code definition is not found.
 * @returns {object} 404 - An error object if the project or segment is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/code/:segmentId', requireAuth, async (req, res) => {
  const { projectId, segmentId } = req.params;
  const { codeId } = req.body;
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const segmentToUpdate = project.codedSegments.id(segmentId);
    if (!segmentToUpdate) return res.status(404).json({ error: 'Coded segment not found' });
    const newCodeDef = project.codeDefinitions.id(codeId);
    if (!newCodeDef) return res.status(400).json({ error: 'The new code definition was not found' });
    segmentToUpdate.codeDefinition = { _id: newCodeDef._id, name: newCodeDef.name, description: newCodeDef.description, color: newCodeDef.color, };
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error("Error updating coded segment:", err);
    res.status(500).json({ error: 'Update failed', details: err.message });
  }
});

/**
 * Merges multiple code definitions into a single new one.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {Array<string>} req.body.sourceCodeIds - An array of code definition IDs to merge.
 * @param {string} req.body.newCodeName - The name for the new merged code.
 * @param {string} req.body.newCodeColor - The color for the new merged code.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object for invalid request data.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the merge fails.
 */
router.post('/:projectId/codes/merge', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const { sourceCodeIds, newCodeName, newCodeColor } = req.body;
  if (!sourceCodeIds || !Array.isArray(sourceCodeIds) || sourceCodeIds.length < 2 || !newCodeName || !newCodeName.trim()) {
    return res.status(400).json({ error: 'Invalid request data. Requires an array of at least two source code IDs and a non-empty new name.' });
  }
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const newCodeDefinition = {
      _id: new mongoose.Types.ObjectId(),
      name: newCodeName,
      color: newCodeColor,
      description: `Merged from codes.`,
      owner: req.userId
    };
    project.codeDefinitions.push(newCodeDefinition);
    project.codedSegments.forEach(segment => {
      if (sourceCodeIds.includes(segment.codeDefinition._id.toString())) {
        segment.codeDefinition = {
          _id: newCodeDefinition._id,
          name: newCodeDefinition.name,
          color: newCodeDefinition.color,
          description: newCodeDefinition.description,
        };
      }
    });
    project.codeDefinitions = project.codeDefinitions.filter(
      def => !sourceCodeIds.includes(def._id.toString())
    );
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error('Merge codes error:', err);
    res.status(500).json({ error: 'Server error during merge', details: err.message });
  }
});

/**
 * Splits a single code definition into multiple new ones and reassigns its segments.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.body.sourceCodeId - The ID of the code definition to split.
 * @param {Array<object>} req.body.newCodeDefinitions - An array of new code definition objects.
 * @param {object} req.body.assignments - An object mapping segment IDs to new code names.
 * @returns {object} 200 - The updated project object.
 * @returns {object} 400 - An error object for invalid request data.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the split fails.
 */
router.post('/:projectId/codes/split', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const { sourceCodeId, newCodeDefinitions, assignments } = req.body;
  if (!sourceCodeId || !newCodeDefinitions || !assignments) {
    return res.status(400).json({ error: 'Invalid request data for split.' });
  }
  try {
    const project = await Project.findOne({ _id: projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const newCodeMap = new Map();
    newCodeDefinitions.forEach(def => {
      const newDef = {
        _id: new mongoose.Types.ObjectId(),
        name: def.name,
        color: def.color,
        description: `Split from original code.`,
        owner: req.userId
      };
      project.codeDefinitions.push(newDef);
      newCodeMap.set(def.name, newDef);
    });
    for (const segmentId in assignments) {
      const newCodeIdentifier = assignments[segmentId];
      const segment = project.codedSegments.id(segmentId);
      if (!segment) continue;
      if (newCodeIdentifier === null) {
        project.codedSegments.pull({ _id: segmentId });
      } else if (newCodeMap.has(newCodeIdentifier)) {
        const newCode = newCodeMap.get(newCodeIdentifier);
        segment.codeDefinition = { _id: newCode._id, name: newCode.name, color: newCode.color, description: newCode.description, };
      }
    }
    project.codeDefinitions = project.codeDefinitions.filter(def => def._id.toString() !== sourceCodeId);
    await project.save();
    res.json({ project });
  } catch (err) {
    console.error('Split codes error:', err);
    res.status(500).json({ error: 'Server error during split', details: err.message });
  }
});

/**
 * Adds a new inline highlight to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {object} req.body - The highlight data.
 * @returns {object} 200 - The updated project object and the new highlight.
 * @returns {object} 500 - An error object if adding the highlight fails.
 */
router.post('/:projectId/highlight', requireAuth, async (req, res) => {
  const { fileId, fileName, text, color, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $push: { inlineHighlights: { fileId, fileName, text, color, startIndex, endIndex } } }, { new: true });
    const newHighlight = project.inlineHighlights.at(-1);
    res.json({ project, newHighlight });
  } catch (err) {
    res.status(500).json({ error: 'Add highlight failed', details: err.message });
  }
});

/**
 * Deletes an inline highlight from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.highlightId - The ID of the highlight to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/highlight/:highlightId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { inlineHighlights: { _id: req.params.highlightId } } }, { new: true });
    res.json({ message: 'Highlight deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed', details: err.message });
  }
});

/**
 * Deletes multiple inline highlights from a project in bulk.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {Array<string>} req.body.ids - An array of highlight IDs to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 400 - An error object for an invalid request.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.post('/:projectId/highlight/delete-bulk', requireAuth, async (req, res) => {
  const { ids } = req.body;
  if (!ids || !Array.isArray(ids)) {
    return res.status(400).json({ error: 'Invalid request: "ids" array is required.' });
  }
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { inlineHighlights: { _id: { $in: ids } } } }, { new: true });
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    res.json({ message: `${ids.length} highlights deleted`, project });
  } catch (err) {
    res.status(500).json({ error: 'Bulk delete failed', details: err.message });
  }
});

/**
 * Updates an existing memo in a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.memoId - The ID of the memo to update.
 * @param {object} req.body - The updated memo data.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project or memo is not found.
 * @returns {object} 500 - An error object if the update fails.
 */
router.put('/:projectId/memos/:memoId', requireAuth, async (req, res) => {
  const { title, content, text, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const memo = project.memos.id(req.params.memoId);
    if (!memo) return res.status(404).json({ error: 'Memo not found' });
    memo.set({ title, content, text, startIndex, endIndex, updatedAt: new Date() });
    const updatedProject = await project.save();
    res.json({ message: 'Memo updated', project: updatedProject });
  } catch (err) {
    console.error('Update memo error:', err);
    res.status(500).json({ error: 'Update memo failed', details: err.message });
  }
});

/**
 * Adds a new memo to a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {object} req.body - The memo data.
 * @returns {object} 201 - The new memo object and the updated project object.
 * @returns {object} 401 - An error object if the user is not found.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if adding the memo fails.
 */
router.post('/:projectId/memos', requireAuth, async (req, res) => {
  const { fileId, fileName, text, title, content, startIndex, endIndex } = req.body;
  try {
    const project = await Project.findOne({ _id: req.params.projectId, owner: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    const User = mongoose.model('User');
    const user = await User.findById(req.userId);
    if (!user) return res.status(401).json({ error: 'User not found or unauthorized' });
    project.memos.push({
      fileId,
      fileName,
      text,
      title,
      content,
      startIndex,
      endIndex,
      author: user.name,
      authorId: req.userId,
      createdAt: new Date(),
    });
    await project.save();
    res.status(201).json({ newMemo: project.memos.at(-1), project });
  } catch (err) {
    console.error('Add memo error:', err);
    res.status(500).json({ error: 'Add memo failed', details: err.message });
  }
});

/**
 * Deletes a memo from a project.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.memoId - The ID of the memo to delete.
 * @returns {object} 200 - A success message and the updated project object.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the deletion fails.
 */
router.delete('/:projectId/memos/:memoId', requireAuth, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate({ _id: req.params.projectId, owner: req.userId }, { $pull: { memos: { _id: req.params.memoId } } }, { new: true });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    res.json({ message: 'Memo deleted', project });
  } catch (err) {
    res.status(500).json({ error: 'Delete memo failed', details: err.message });
  }
});

/**
 * Converts a HEX color string to an ARGB string for ExcelJS.
 * @param {string} hex - The hex color code.
 * @param {number} [alpha=1.0] - The alpha transparency value.
 * @returns {string} The ARGB color string.
 */
const hexToArgb = (hex, alpha = 1.0) => {
  if (!hex || !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {
    hex = '#CCCCCC';
  }
  let cleanHex = hex.substring(1);
  if (cleanHex.length === 3) {
    cleanHex = cleanHex.split('').map(char => char + char).join('');
  }
  const alphaHex = Math.round(alpha * 255).toString(16).padStart(2, '0').toUpperCase();
  return `${alphaHex}${cleanHex}`;
};

/**
 * Creates a subtle color scheme for Excel cell styling.
 * @param {string} baseHex - The base hex color.
 * @returns {object} An object with fill and border styles.
 */
const createSubtleColorScheme = (baseHex) => {
  return {
    nameCell: { type: 'pattern', pattern: 'solid', fgColor: { argb: hexToArgb(baseHex, 0.15) } },
    contentRows: { type: 'pattern', pattern: 'solid', fgColor: { argb: hexToArgb(baseHex, 0.05) } },
    leftBorder: {
      left: { style: 'thick', color: { argb: hexToArgb(baseHex, 0.8) } },
      right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
    },
    standardBorder: {
      left: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
    }
  };
};

/**
 * Applies a subtle color scheme to a range of cells in an Excel worksheet.
 * @param {object} worksheet - The ExcelJS worksheet object.
 * @param {number} codeStartRow - The starting row for the colored block.
 * @param {number} codeEndRow - The ending row for the colored block.
 * @param {string} baseHexColor - The base hex color for styling.
 * @param {object} columns - An object defining column letters.
 * @returns {void}
 */
const applySubtleColoring = (worksheet, codeStartRow, codeEndRow, baseHexColor, columns) => {
  const colors = createSubtleColorScheme(baseHexColor);
  const nameColumn = columns.nameColumn;
  worksheet.getCell(`${nameColumn}${codeStartRow}`).fill = colors.nameCell;
  worksheet.getCell(`${nameColumn}${codeStartRow}`).font = { bold: true };
  worksheet.getCell(`${nameColumn}${codeStartRow}`).border = colors.leftBorder;
  columns.otherColumns.forEach(col => {
    worksheet.getCell(`${col}${codeStartRow}`).fill = colors.contentRows;
    worksheet.getCell(`${col}${codeStartRow}`).border = colors.standardBorder;
  });
  for (let i = codeStartRow; i <= codeEndRow; i++) {
    columns.contentColumns.forEach(col => {
      worksheet.getCell(`${col}${i}`).fill = colors.contentRows;
      worksheet.getCell(`${col}${i}`).border = colors.standardBorder;
      worksheet.getCell(`${col}${i}`).alignment = { vertical: 'top', horizontal: 'left', wrapText: true };
    });
  }
  worksheet.getCell(`${nameColumn}${codeStartRow}`).alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
  columns.otherColumns.forEach(col => {
    worksheet.getCell(`${col}${codeStartRow}`).alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
  });
};

/**
 * Exports all coded segments from a project to an Excel file.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} [req.query.format='byDocument'] - The format of the export ('byDocument' or 'overall').
 * @returns {File} 200 - The generated Excel file.
 * @returns {object} 404 - An error object if the project is not found.
 * @returns {object} 500 - An error object if the export fails.
 */
router.get('/:projectId/export-coded-segments', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const userId = req.userId;
  const { format = 'byDocument' } = req.query;
  try {
    const project = await Project.findOne({ _id: projectId, owner: userId }).lean();
    if (!project) {
      return res.status(404).json({ error: 'Project not found or unauthorized' });
    }
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Coded Segments');
    let totalFrequency = 0;
    if (format === 'overall') {
      worksheet.columns = [
        { header: 'Code Definition', key: 'codeName', width: 30 },
        { header: 'Code Description', key: 'codeDescription', width: 40 },
        { header: 'File Name', key: 'fileName', width: 30 },
        { header: 'Coded Segment Text', key: 'text', width: 60 },
        { header: 'Frequency', key: 'frequency', width: 15 },
      ];
      worksheet.getRow(1).font = { bold: true, color: { argb: 'FFFFFFFF' } };
      worksheet.getRow(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF444444' } };
      worksheet.getRow(1).alignment = { vertical: 'middle', horizontal: 'center' };
      const groupedByCode = {};
      project.codedSegments.forEach(segment => {
        const defId = segment.codeDefinition?._id?.toString() || 'undefined';
        if (!groupedByCode[defId]) {
          groupedByCode[defId] = { definition: segment.codeDefinition, segments: [] };
        }
        groupedByCode[defId].segments.push(segment);
      });
      let currentRow = 2;
      for (const { definition, segments } of Object.values(groupedByCode)) {
        const codeStartRow = currentRow;
        const baseHexColor = definition?.color || '#CCCCCC';
        for (const segment of segments) {
          worksheet.addRow({ fileName: segment.fileName || 'Unknown', text: `"${segment.text || ''}"` });
          currentRow++;
        }
        const codeEndRow = currentRow - 1;
        worksheet.mergeCells(`A${codeStartRow}:A${codeEndRow}`);
        worksheet.mergeCells(`B${codeStartRow}:B${codeEndRow}`);
        worksheet.mergeCells(`E${codeStartRow}:E${codeEndRow}`);
        worksheet.getCell(`A${codeStartRow}`).value = definition?.name || 'Unknown Code';
        worksheet.getCell(`B${codeStartRow}`).value = definition?.description || 'No description';
        worksheet.getCell(`E${codeStartRow}`).value = segments.length;
        applySubtleColoring(worksheet, codeStartRow, codeEndRow, baseHexColor, {
          nameColumn: 'A',
          otherColumns: ['B', 'E'],
          contentColumns: ['C', 'D']
        });
      }
      totalFrequency = project.codedSegments.length;
    } else {
      worksheet.columns = [
        { header: 'File Name', key: 'fileName', width: 30 },
        { header: 'Code Definition', key: 'codeName', width: 25 },
        { header: 'Code Description', key: 'codeDescription', width: 40 },
        { header: 'Coded Segment Text', key: 'text', width: 60 },
        { header: 'Frequency', key: 'frequency', width: 15 },
      ];
      worksheet.getRow(1).font = { bold: true, color: { argb: 'FFFFFFFF' } };
      worksheet.getRow(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF444444' } };
      worksheet.getRow(1).alignment = { vertical: 'middle', horizontal: 'center' };
      const groupedByFile = {};
      project.codedSegments.forEach(segment => {
        const fileName = segment.fileName || 'Unknown File';
        if (!groupedByFile[fileName]) groupedByFile[fileName] = [];
        groupedByFile[fileName].push(segment);
      });
      let currentRow = 2;
      for (const [fileName, segmentsInFile] of Object.entries(groupedByFile)) {
        const fileStartRow = currentRow;
        const groupedByCode = {};
        segmentsInFile.forEach(segment => {
          const defId = segment.codeDefinition?._id?.toString() || 'undefined';
          if (!groupedByCode[defId]) {
            groupedByCode[defId] = { definition: segment.codeDefinition, segments: [] };
          }
          groupedByCode[defId].segments.push(segment);
        });
        for (const { definition, segments } of Object.values(groupedByCode)) {
          const codeStartRow = currentRow;
          const baseHexColor = definition?.color || '#CCCCCC';
          for (const segment of segments) {
            worksheet.addRow({ text: `"${segment.text || ''}"` });
            currentRow++;
          }
          const codeEndRow = currentRow - 1;
          worksheet.mergeCells(`B${codeStartRow}:B${codeEndRow}`);
          worksheet.mergeCells(`C${codeStartRow}:C${codeEndRow}`);
          worksheet.mergeCells(`E${codeStartRow}:E${codeEndRow}`);
          worksheet.getCell(`B${codeStartRow}`).value = definition?.name || 'Unknown Code';
          worksheet.getCell(`C${codeStartRow}`).value = definition?.description || 'No description';
          worksheet.getCell(`E${codeStartRow}`).value = segments.length;
          applySubtleColoring(worksheet, codeStartRow, codeEndRow, baseHexColor, {
            nameColumn: 'B',
            otherColumns: ['C', 'E'],
            contentColumns: ['D']
          });
        }
        const fileEndRow = currentRow - 1;
        if (fileEndRow >= fileStartRow) {
          worksheet.mergeCells(`A${fileStartRow}:A${fileEndRow}`);
          worksheet.getCell(`A${fileStartRow}`).value = fileName;
          worksheet.getCell(`A${fileStartRow}`).alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
          worksheet.getCell(`A${fileStartRow}`).font = { bold: true };
          worksheet.getCell(`A${fileStartRow}`).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF5F5F5' } };
          worksheet.getCell(`A${fileStartRow}`).border = {
            left: { style: 'thick', color: { argb: 'FF666666' } },
            right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
            top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
            bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
          };
        }
      }
      totalFrequency = project.codedSegments.length;
    }
    const totalRow = worksheet.addRow({});
    const totalLabelCell = worksheet.getCell(totalRow.number, worksheet.columns.length - 1);
    const totalValueCell = worksheet.getCell(totalRow.number, worksheet.columns.length);
    totalLabelCell.value = 'Total Frequency';
    totalValueCell.value = totalFrequency;
    totalLabelCell.font = { bold: true };
    totalValueCell.font = { bold: true };
    totalLabelCell.alignment = { horizontal: 'right' };
    totalValueCell.alignment = { horizontal: 'center' };
    totalLabelCell.border = {
      left: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      top: { style: 'thick', color: { argb: 'FF666666' } },
      bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
    };
    totalValueCell.border = {
      left: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
      top: { style: 'thick', color: { argb: 'FF666666' } },
      bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } }
    };
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename="${project.name}_coded_segments_${format}.xlsx"`);
    await workbook.xlsx.write(res);
    res.end();
  } catch (err) {
    console.error('[EXPORT ERROR]', err);
    res.status(500).json({ error: 'Failed to export coded segments', details: err.message });
  }
});

/**
 * Exports all overlapping code segments, with UI-aligned color styling for codes,
 * to a single Excel worksheet that includes a full statistical summary.
 * @param {string} req.params.projectId - The ID of the project.
 * @returns {File} 200 - The generated Excel file.
 * @returns {object} 404 - An error object if the project is not found or no overlaps exist.
 * @returns {object} 500 - An error object if the export fails.
 */
router.get('/:projectId/export-overlaps', requireAuth, async (req, res) => {
  const { projectId } = req.params;
  const userId = req.userId;

  // const hexToArgb = (hex) => {
  //   if (!hex || !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {
  //       return 'FFCCCCCC';
  //   }
  //   return `FF${hex.replace('#', '')}`;
  // };

  try {
    const project = await Project.findOne({ _id: projectId, owner: userId }).lean();
    if (!project) {
      return res.status(404).json({ error: 'Project not found or unauthorized' });
    }

    const overlapsByFile = {};
    const segmentsByFile = project.codedSegments.reduce((acc, segment) => {
      const fileId = segment.fileId.toString();
      if (!acc[fileId]) acc[fileId] = [];
      acc[fileId].push(segment);
      return acc;
    }, {});

    for (const fileId in segmentsByFile) {
        const segments = segmentsByFile[fileId];
        if (segments.length < 2) continue;
        const file = project.importedFiles.find(f => f._id.toString() === fileId);
        if (!file?.content) continue;

        const boundaryPoints = new Set();
        segments.forEach(s => {
            boundaryPoints.add(s.startIndex);
            boundaryPoints.add(s.endIndex);
        });
        const sortedPoints = Array.from(boundaryPoints).sort((a, b) => a - b);

        const fileOverlaps = [];
        for (let i = 0; i < sortedPoints.length - 1; i++) {
            const intervalStart = sortedPoints[i];
            const intervalEnd = sortedPoints[i + 1];
            if (intervalStart === intervalEnd) continue;

            const coveringSegments = segments.filter(s => s.startIndex <= intervalStart && s.endIndex >= intervalEnd);
            if (coveringSegments.length > 1) {
                const allCodes = coveringSegments.map(s => s.codeDefinition).filter(Boolean);
                const uniqueCodes = Array.from(new Map(allCodes.map(code => [code._id.toString(), code])).values());
                fileOverlaps.push({
                    start: intervalStart,
                    end: intervalEnd,
                    text: file.content.substring(intervalStart, intervalEnd),
                    codes: uniqueCodes,
                });
            }
        }

        if (fileOverlaps.length > 0) {
            const mergedOverlaps = [];
            let currentOverlap = { ...fileOverlaps[0] };
            for (let i = 1; i < fileOverlaps.length; i++) {
                const nextOverlap = fileOverlaps[i];
                const currentCodeIds = currentOverlap.codes.map(c => c._id.toString()).sort();
                const nextCodeIds = nextOverlap.codes.map(c => c._id.toString()).sort();
                if (nextOverlap.start === currentOverlap.end && JSON.stringify(currentCodeIds) === JSON.stringify(nextCodeIds)) {
                    currentOverlap.end = nextOverlap.end;
                    currentOverlap.text += nextOverlap.text;
                } else {
                    mergedOverlaps.push(currentOverlap);
                    currentOverlap = { ...nextOverlap };
                }
            }
            mergedOverlaps.push(currentOverlap);
            overlapsByFile[fileId] = { document: file, overlaps: mergedOverlaps };
        }
    }
    
    const finalOverlaps = Object.values(overlapsByFile);
    if (finalOverlaps.length === 0) {
      return res.status(404).json({ error: 'No overlapping codes found in the project to export.' });
    }

    const totalOverlapRegions = finalOverlaps.reduce((total, fileGroup) => total + fileGroup.overlaps.length, 0);
    const documentsWithOverlaps = finalOverlaps.length;
    const totalDocuments = project.importedFiles.length;
    const totalOverlapTextLength = finalOverlaps.reduce((total, fileGroup) => 
        total + fileGroup.overlaps.reduce((fileTotal, overlap) => fileTotal + overlap.text.length, 0), 0
    );
    const averageOverlapLength = totalOverlapRegions > 0 ? Math.round(totalOverlapTextLength / totalOverlapRegions) : 0;
    
    const allOverlapCodes = new Set();
    const codePairFrequency = {};
    finalOverlaps.forEach(fileGroup => {
      fileGroup.overlaps.forEach(overlap => {
        overlap.codes.forEach(code => allOverlapCodes.add(code.name));
        if (overlap.codes.length >= 2) {
          const sortedCodeNames = overlap.codes.map(c => c.name).sort();
          for (let i = 0; i < sortedCodeNames.length; i++) {
            for (let j = i + 1; j < sortedCodeNames.length; j++) {
              const pair = `${sortedCodeNames[i]} & ${sortedCodeNames[j]}`;
              codePairFrequency[pair] = (codePairFrequency[pair] || 0) + 1;
            }
          }
        }
      });
    });
    const uniqueCodesList = Array.from(allOverlapCodes).sort();
    const mostFrequentPair = Object.entries(codePairFrequency).sort(([,a], [,b]) => b - a)[0];

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Overlapping Codes Report');
    
    worksheet.getCell('A1').value = 'Total Overlap Regions:';
    worksheet.getCell('B1').value = totalOverlapRegions;
    worksheet.getCell('C1').value = 'Documents with Overlaps:';
    worksheet.getCell('D1').value = `${documentsWithOverlaps} / ${totalDocuments} Docs`;
    worksheet.getCell('E1').value = 'Most Frequent Pair:';
    worksheet.getCell('F1').value = mostFrequentPair ? `${mostFrequentPair[0]} (${mostFrequentPair[1]} times)` : 'N/A';
    
    worksheet.getCell('A2').value = 'Unique Codes Involved:';
    worksheet.getCell('B2').value = uniqueCodesList.join(', ') || 'N/A';
    worksheet.getCell('C2').value = 'Total Overlap Text:';
    worksheet.getCell('D2').value = `${totalOverlapTextLength} characters`;
    worksheet.getCell('E2').value = 'Average Overlap Length:';
    worksheet.getCell('F2').value = `${averageOverlapLength} characters`;
    
    [1, 2].forEach(rowNum => {
      worksheet.getRow(rowNum).eachCell({ includeEmpty: true }, (cell, colNum) => {
        if (colNum % 2 === 1) { 
          cell.font = { bold: true };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF0F2F5' } };
        } else { 
          cell.font = { color: { argb: 'FF1D3C87' } };
        }
        cell.border = { top: {style:'thin'}, left: {style:'thin'}, bottom: {style:'thin'}, right: {style:'thin'} };
        cell.alignment = { vertical: 'middle', horizontal: 'left', wrapText: true };
      });
    });
    
    worksheet.addRow({});
    const headerRow = worksheet.getRow(4);
    headerRow.values = ['File Name', 'Overlapping Text', 'Applied Codes', 'Code Count'];
    headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF444444' } };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    
    worksheet.getColumn('A').width = 30;
    worksheet.getColumn('B').width = 60;
    worksheet.getColumn('C').width = 40;
    worksheet.getColumn('D').width = 15;
    worksheet.getColumn('E').width = 30;
    worksheet.getColumn('F').width = 40; 

    let currentRowIndex = 5;
    finalOverlaps.forEach(fileGroup => {
      const fileStartRow = currentRowIndex;
      fileGroup.overlaps.forEach(overlap => {
        
        const richTextValue = [];
        overlap.codes.forEach((code, index) => {
          richTextValue.push({
            text: code.name,
            font: {
              color: { argb: hexToArgb(code.color || '#808080') }, 
              bold: true,
            }
          });
          if (index < overlap.codes.length - 1) {
            richTextValue.push({
              text: ', ',
              font: { color: { argb: 'FF000000' } } 
            });
          }
        });
        
        const rowData = [
          null, 
          `"${overlap.text}"`,
          { richText: richTextValue }, 
          overlap.codes.length
        ];
        
        worksheet.addRow(rowData);
        currentRowIndex++;
      });
      
      const fileEndRow = currentRowIndex - 1;
      if (fileEndRow >= fileStartRow) {
        worksheet.mergeCells(`A${fileStartRow}:A${fileEndRow}`);
        const fileNameCell = worksheet.getCell(`A${fileStartRow}`);
        fileNameCell.value = fileGroup.document.name;
        fileNameCell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
        fileNameCell.font = { bold: true };
        fileNameCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF5F5F5' } };
      }
    });

    for (let i = 4; i < currentRowIndex; i++) {
        const row = worksheet.getRow(i);
        row.eachCell({ includeEmpty: true }, (cell) => {
            cell.border = { top: {style:'thin'}, left: {style:'thin'}, bottom: {style:'thin'}, right: {style:'thin'} };
            if (i > 4) {
                 cell.alignment = { ...cell.alignment, vertical: 'top', wrapText: true };
            }
        });
    }

    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename="${project.name}_overlaps_report.xlsx"`);
    await workbook.xlsx.write(res);
    res.end();

  } catch (err) {
    console.error('[OVERLAPS EXPORT ERROR]', err);
    res.status(500).json({ error: 'Failed to export overlapping codes', details: err.message });
  }
});

/**
 * Exports all memos for a single file to an Excel file.
 * @param {string} req.params.projectId - The ID of the project.
 * @param {string} req.params.fileId - The ID of the file to export memos from.
 * @returns {File} 200 - The generated Excel file.
 * @returns {object} 404 - An error object if the project or file is not found.
 * @returns {object} 500 - An error object if the export fails.
 */
router.get('/:projectId/files/:fileId/export-memos', requireAuth, async (req, res) => {
  const { projectId, fileId } = req.params;
  try {
    const project = await Project.findById(projectId);
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const file = project.importedFiles.id(fileId);
    if (!file) return res.status(404).json({ error: 'File not found' });

    const memosForFile = project.memos.filter(memo => memo.fileId && memo.fileId.toString() === fileId);
    if (memosForFile.length === 0) {
      return res.status(404).json({ error: 'No memos found for this file.' });
    }

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Memos');
    worksheet.columns = [
      { header: 'File Name', key: 'fileName', width: 25 },
      { header: 'Title', key: 'title', width: 30 },
      { header: 'Content', key: 'content', width: 50 },
      { header: 'Author', key: 'author', width: 20 },
      { header: 'Created At', key: 'createdAt', width: 25 },
    ];
    memosForFile.forEach(memo => {
      worksheet.addRow({
        fileName: memo.fileName,
        title: memo.title || '',
        content: memo.content,
        author: memo.author,
        createdAt: memo.createdAt ?
          memo.createdAt.toLocaleString('en-GB', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
          }) :
          '',
      });
    });

    const sanitizedFileName = file.name.replace(/\.[^/.]+$/, '').replace(/[^\w\s-]/g, '').replace(/\s+/g, '_');
    res.setHeader(
      'Content-Type',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );
    res.setHeader('Content-Disposition', `attachment; filename=${sanitizedFileName}_memos.xlsx`);
    await workbook.xlsx.write(res);
    res.end();
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to export memos.' });
  }
});

export default router;